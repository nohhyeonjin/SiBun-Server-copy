module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateChatContent {
  count: Int!
}

type AggregateChatRoom {
  count: Int!
}

type AggregateIndividualOrder {
  count: Int!
}

type AggregateMenu {
  count: Int!
}

type AggregateMenuCategory {
  count: Int!
}

type AggregateRoomOrder {
  count: Int!
}

type AggregateStore {
  count: Int!
}

type AggregateStoreCategory {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ChatContent {
  id: ID!
  user: User!
  chatRoom: ChatRoom!
  content: String!
}

type ChatContentConnection {
  pageInfo: PageInfo!
  edges: [ChatContentEdge]!
  aggregate: AggregateChatContent!
}

input ChatContentCreateInput {
  id: ID
  user: UserCreateOneInput!
  chatRoom: ChatRoomCreateOneWithoutChatContentListInput!
  content: String!
}

input ChatContentCreateManyWithoutChatRoomInput {
  create: [ChatContentCreateWithoutChatRoomInput!]
  connect: [ChatContentWhereUniqueInput!]
}

input ChatContentCreateWithoutChatRoomInput {
  id: ID
  user: UserCreateOneInput!
  content: String!
}

type ChatContentEdge {
  node: ChatContent!
  cursor: String!
}

enum ChatContentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
}

type ChatContentPreviousValues {
  id: ID!
  content: String!
}

input ChatContentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [ChatContentScalarWhereInput!]
  OR: [ChatContentScalarWhereInput!]
  NOT: [ChatContentScalarWhereInput!]
}

type ChatContentSubscriptionPayload {
  mutation: MutationType!
  node: ChatContent
  updatedFields: [String!]
  previousValues: ChatContentPreviousValues
}

input ChatContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatContentWhereInput
  AND: [ChatContentSubscriptionWhereInput!]
  OR: [ChatContentSubscriptionWhereInput!]
  NOT: [ChatContentSubscriptionWhereInput!]
}

input ChatContentUpdateInput {
  user: UserUpdateOneRequiredInput
  chatRoom: ChatRoomUpdateOneRequiredWithoutChatContentListInput
  content: String
}

input ChatContentUpdateManyDataInput {
  content: String
}

input ChatContentUpdateManyMutationInput {
  content: String
}

input ChatContentUpdateManyWithoutChatRoomInput {
  create: [ChatContentCreateWithoutChatRoomInput!]
  delete: [ChatContentWhereUniqueInput!]
  connect: [ChatContentWhereUniqueInput!]
  set: [ChatContentWhereUniqueInput!]
  disconnect: [ChatContentWhereUniqueInput!]
  update: [ChatContentUpdateWithWhereUniqueWithoutChatRoomInput!]
  upsert: [ChatContentUpsertWithWhereUniqueWithoutChatRoomInput!]
  deleteMany: [ChatContentScalarWhereInput!]
  updateMany: [ChatContentUpdateManyWithWhereNestedInput!]
}

input ChatContentUpdateManyWithWhereNestedInput {
  where: ChatContentScalarWhereInput!
  data: ChatContentUpdateManyDataInput!
}

input ChatContentUpdateWithoutChatRoomDataInput {
  user: UserUpdateOneRequiredInput
  content: String
}

input ChatContentUpdateWithWhereUniqueWithoutChatRoomInput {
  where: ChatContentWhereUniqueInput!
  data: ChatContentUpdateWithoutChatRoomDataInput!
}

input ChatContentUpsertWithWhereUniqueWithoutChatRoomInput {
  where: ChatContentWhereUniqueInput!
  update: ChatContentUpdateWithoutChatRoomDataInput!
  create: ChatContentCreateWithoutChatRoomInput!
}

input ChatContentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  chatRoom: ChatRoomWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [ChatContentWhereInput!]
  OR: [ChatContentWhereInput!]
  NOT: [ChatContentWhereInput!]
}

input ChatContentWhereUniqueInput {
  id: ID
}

type ChatRoom {
  id: ID!
  boss: User!
  memberList(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  store: Store!
  location: String!
  orderExpectedTime: DateTime!
  individualOrderList(where: IndividualOrderWhereInput, orderBy: IndividualOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IndividualOrder!]
  chatContentList(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatContent!]
  state: Boolean!
}

type ChatRoomConnection {
  pageInfo: PageInfo!
  edges: [ChatRoomEdge]!
  aggregate: AggregateChatRoom!
}

input ChatRoomCreateInput {
  id: ID
  boss: UserCreateOneWithoutChatListInput!
  memberList: UserCreateManyInput
  store: StoreCreateOneInput!
  location: String!
  orderExpectedTime: DateTime!
  individualOrderList: IndividualOrderCreateManyWithoutChatRoomInput
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateManyWithoutBossInput {
  create: [ChatRoomCreateWithoutBossInput!]
  connect: [ChatRoomWhereUniqueInput!]
}

input ChatRoomCreateOneInput {
  create: ChatRoomCreateInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateOneWithoutChatContentListInput {
  create: ChatRoomCreateWithoutChatContentListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateOneWithoutIndividualOrderListInput {
  create: ChatRoomCreateWithoutIndividualOrderListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateWithoutBossInput {
  id: ID
  memberList: UserCreateManyInput
  store: StoreCreateOneInput!
  location: String!
  orderExpectedTime: DateTime!
  individualOrderList: IndividualOrderCreateManyWithoutChatRoomInput
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateWithoutChatContentListInput {
  id: ID
  boss: UserCreateOneWithoutChatListInput!
  memberList: UserCreateManyInput
  store: StoreCreateOneInput!
  location: String!
  orderExpectedTime: DateTime!
  individualOrderList: IndividualOrderCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateWithoutIndividualOrderListInput {
  id: ID
  boss: UserCreateOneWithoutChatListInput!
  memberList: UserCreateManyInput
  store: StoreCreateOneInput!
  location: String!
  orderExpectedTime: DateTime!
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

type ChatRoomEdge {
  node: ChatRoom!
  cursor: String!
}

enum ChatRoomOrderByInput {
  id_ASC
  id_DESC
  location_ASC
  location_DESC
  orderExpectedTime_ASC
  orderExpectedTime_DESC
  state_ASC
  state_DESC
}

type ChatRoomPreviousValues {
  id: ID!
  location: String!
  orderExpectedTime: DateTime!
  state: Boolean!
}

input ChatRoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  orderExpectedTime: DateTime
  orderExpectedTime_not: DateTime
  orderExpectedTime_in: [DateTime!]
  orderExpectedTime_not_in: [DateTime!]
  orderExpectedTime_lt: DateTime
  orderExpectedTime_lte: DateTime
  orderExpectedTime_gt: DateTime
  orderExpectedTime_gte: DateTime
  state: Boolean
  state_not: Boolean
  AND: [ChatRoomScalarWhereInput!]
  OR: [ChatRoomScalarWhereInput!]
  NOT: [ChatRoomScalarWhereInput!]
}

type ChatRoomSubscriptionPayload {
  mutation: MutationType!
  node: ChatRoom
  updatedFields: [String!]
  previousValues: ChatRoomPreviousValues
}

input ChatRoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatRoomWhereInput
  AND: [ChatRoomSubscriptionWhereInput!]
  OR: [ChatRoomSubscriptionWhereInput!]
  NOT: [ChatRoomSubscriptionWhereInput!]
}

input ChatRoomUpdateDataInput {
  boss: UserUpdateOneRequiredWithoutChatListInput
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  individualOrderList: IndividualOrderUpdateManyWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateInput {
  boss: UserUpdateOneRequiredWithoutChatListInput
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  individualOrderList: IndividualOrderUpdateManyWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateManyDataInput {
  location: String
  orderExpectedTime: DateTime
  state: Boolean
}

input ChatRoomUpdateManyMutationInput {
  location: String
  orderExpectedTime: DateTime
  state: Boolean
}

input ChatRoomUpdateManyWithoutBossInput {
  create: [ChatRoomCreateWithoutBossInput!]
  delete: [ChatRoomWhereUniqueInput!]
  connect: [ChatRoomWhereUniqueInput!]
  set: [ChatRoomWhereUniqueInput!]
  disconnect: [ChatRoomWhereUniqueInput!]
  update: [ChatRoomUpdateWithWhereUniqueWithoutBossInput!]
  upsert: [ChatRoomUpsertWithWhereUniqueWithoutBossInput!]
  deleteMany: [ChatRoomScalarWhereInput!]
  updateMany: [ChatRoomUpdateManyWithWhereNestedInput!]
}

input ChatRoomUpdateManyWithWhereNestedInput {
  where: ChatRoomScalarWhereInput!
  data: ChatRoomUpdateManyDataInput!
}

input ChatRoomUpdateOneRequiredInput {
  create: ChatRoomCreateInput
  update: ChatRoomUpdateDataInput
  upsert: ChatRoomUpsertNestedInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateOneRequiredWithoutChatContentListInput {
  create: ChatRoomCreateWithoutChatContentListInput
  update: ChatRoomUpdateWithoutChatContentListDataInput
  upsert: ChatRoomUpsertWithoutChatContentListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateOneRequiredWithoutIndividualOrderListInput {
  create: ChatRoomCreateWithoutIndividualOrderListInput
  update: ChatRoomUpdateWithoutIndividualOrderListDataInput
  upsert: ChatRoomUpsertWithoutIndividualOrderListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateWithoutBossDataInput {
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  individualOrderList: IndividualOrderUpdateManyWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithoutChatContentListDataInput {
  boss: UserUpdateOneRequiredWithoutChatListInput
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  individualOrderList: IndividualOrderUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithoutIndividualOrderListDataInput {
  boss: UserUpdateOneRequiredWithoutChatListInput
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithWhereUniqueWithoutBossInput {
  where: ChatRoomWhereUniqueInput!
  data: ChatRoomUpdateWithoutBossDataInput!
}

input ChatRoomUpsertNestedInput {
  update: ChatRoomUpdateDataInput!
  create: ChatRoomCreateInput!
}

input ChatRoomUpsertWithoutChatContentListInput {
  update: ChatRoomUpdateWithoutChatContentListDataInput!
  create: ChatRoomCreateWithoutChatContentListInput!
}

input ChatRoomUpsertWithoutIndividualOrderListInput {
  update: ChatRoomUpdateWithoutIndividualOrderListDataInput!
  create: ChatRoomCreateWithoutIndividualOrderListInput!
}

input ChatRoomUpsertWithWhereUniqueWithoutBossInput {
  where: ChatRoomWhereUniqueInput!
  update: ChatRoomUpdateWithoutBossDataInput!
  create: ChatRoomCreateWithoutBossInput!
}

input ChatRoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  boss: UserWhereInput
  memberList_every: UserWhereInput
  memberList_some: UserWhereInput
  memberList_none: UserWhereInput
  store: StoreWhereInput
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  orderExpectedTime: DateTime
  orderExpectedTime_not: DateTime
  orderExpectedTime_in: [DateTime!]
  orderExpectedTime_not_in: [DateTime!]
  orderExpectedTime_lt: DateTime
  orderExpectedTime_lte: DateTime
  orderExpectedTime_gt: DateTime
  orderExpectedTime_gte: DateTime
  individualOrderList_every: IndividualOrderWhereInput
  individualOrderList_some: IndividualOrderWhereInput
  individualOrderList_none: IndividualOrderWhereInput
  chatContentList_every: ChatContentWhereInput
  chatContentList_some: ChatContentWhereInput
  chatContentList_none: ChatContentWhereInput
  state: Boolean
  state_not: Boolean
  AND: [ChatRoomWhereInput!]
  OR: [ChatRoomWhereInput!]
  NOT: [ChatRoomWhereInput!]
}

input ChatRoomWhereUniqueInput {
  id: ID
}

scalar DateTime

type IndividualOrder {
  id: ID!
  user: User!
  menuList(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  chatRoom: ChatRoom!
}

type IndividualOrderConnection {
  pageInfo: PageInfo!
  edges: [IndividualOrderEdge]!
  aggregate: AggregateIndividualOrder!
}

input IndividualOrderCreateInput {
  id: ID
  user: UserCreateOneInput!
  menuList: MenuCreateManyInput
  chatRoom: ChatRoomCreateOneWithoutIndividualOrderListInput!
}

input IndividualOrderCreateManyInput {
  create: [IndividualOrderCreateInput!]
  connect: [IndividualOrderWhereUniqueInput!]
}

input IndividualOrderCreateManyWithoutChatRoomInput {
  create: [IndividualOrderCreateWithoutChatRoomInput!]
  connect: [IndividualOrderWhereUniqueInput!]
}

input IndividualOrderCreateWithoutChatRoomInput {
  id: ID
  user: UserCreateOneInput!
  menuList: MenuCreateManyInput
}

type IndividualOrderEdge {
  node: IndividualOrder!
  cursor: String!
}

enum IndividualOrderOrderByInput {
  id_ASC
  id_DESC
}

type IndividualOrderPreviousValues {
  id: ID!
}

input IndividualOrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [IndividualOrderScalarWhereInput!]
  OR: [IndividualOrderScalarWhereInput!]
  NOT: [IndividualOrderScalarWhereInput!]
}

type IndividualOrderSubscriptionPayload {
  mutation: MutationType!
  node: IndividualOrder
  updatedFields: [String!]
  previousValues: IndividualOrderPreviousValues
}

input IndividualOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IndividualOrderWhereInput
  AND: [IndividualOrderSubscriptionWhereInput!]
  OR: [IndividualOrderSubscriptionWhereInput!]
  NOT: [IndividualOrderSubscriptionWhereInput!]
}

input IndividualOrderUpdateDataInput {
  user: UserUpdateOneRequiredInput
  menuList: MenuUpdateManyInput
  chatRoom: ChatRoomUpdateOneRequiredWithoutIndividualOrderListInput
}

input IndividualOrderUpdateInput {
  user: UserUpdateOneRequiredInput
  menuList: MenuUpdateManyInput
  chatRoom: ChatRoomUpdateOneRequiredWithoutIndividualOrderListInput
}

input IndividualOrderUpdateManyInput {
  create: [IndividualOrderCreateInput!]
  update: [IndividualOrderUpdateWithWhereUniqueNestedInput!]
  upsert: [IndividualOrderUpsertWithWhereUniqueNestedInput!]
  delete: [IndividualOrderWhereUniqueInput!]
  connect: [IndividualOrderWhereUniqueInput!]
  set: [IndividualOrderWhereUniqueInput!]
  disconnect: [IndividualOrderWhereUniqueInput!]
  deleteMany: [IndividualOrderScalarWhereInput!]
}

input IndividualOrderUpdateManyWithoutChatRoomInput {
  create: [IndividualOrderCreateWithoutChatRoomInput!]
  delete: [IndividualOrderWhereUniqueInput!]
  connect: [IndividualOrderWhereUniqueInput!]
  set: [IndividualOrderWhereUniqueInput!]
  disconnect: [IndividualOrderWhereUniqueInput!]
  update: [IndividualOrderUpdateWithWhereUniqueWithoutChatRoomInput!]
  upsert: [IndividualOrderUpsertWithWhereUniqueWithoutChatRoomInput!]
  deleteMany: [IndividualOrderScalarWhereInput!]
}

input IndividualOrderUpdateWithoutChatRoomDataInput {
  user: UserUpdateOneRequiredInput
  menuList: MenuUpdateManyInput
}

input IndividualOrderUpdateWithWhereUniqueNestedInput {
  where: IndividualOrderWhereUniqueInput!
  data: IndividualOrderUpdateDataInput!
}

input IndividualOrderUpdateWithWhereUniqueWithoutChatRoomInput {
  where: IndividualOrderWhereUniqueInput!
  data: IndividualOrderUpdateWithoutChatRoomDataInput!
}

input IndividualOrderUpsertWithWhereUniqueNestedInput {
  where: IndividualOrderWhereUniqueInput!
  update: IndividualOrderUpdateDataInput!
  create: IndividualOrderCreateInput!
}

input IndividualOrderUpsertWithWhereUniqueWithoutChatRoomInput {
  where: IndividualOrderWhereUniqueInput!
  update: IndividualOrderUpdateWithoutChatRoomDataInput!
  create: IndividualOrderCreateWithoutChatRoomInput!
}

input IndividualOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  menuList_every: MenuWhereInput
  menuList_some: MenuWhereInput
  menuList_none: MenuWhereInput
  chatRoom: ChatRoomWhereInput
  AND: [IndividualOrderWhereInput!]
  OR: [IndividualOrderWhereInput!]
  NOT: [IndividualOrderWhereInput!]
}

input IndividualOrderWhereUniqueInput {
  id: ID
}

scalar Long

type Menu {
  id: ID!
  name: String!
  store: Store!
  price: Int!
  menuCategory: MenuCategory!
}

type MenuCategory {
  id: ID!
  name: String!
  store: Store!
}

type MenuCategoryConnection {
  pageInfo: PageInfo!
  edges: [MenuCategoryEdge]!
  aggregate: AggregateMenuCategory!
}

input MenuCategoryCreateInput {
  id: ID
  name: String!
  store: StoreCreateOneWithoutMenuCategoryListInput!
}

input MenuCategoryCreateManyWithoutStoreInput {
  create: [MenuCategoryCreateWithoutStoreInput!]
  connect: [MenuCategoryWhereUniqueInput!]
}

input MenuCategoryCreateOneInput {
  create: MenuCategoryCreateInput
  connect: MenuCategoryWhereUniqueInput
}

input MenuCategoryCreateWithoutStoreInput {
  id: ID
  name: String!
}

type MenuCategoryEdge {
  node: MenuCategory!
  cursor: String!
}

enum MenuCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type MenuCategoryPreviousValues {
  id: ID!
  name: String!
}

input MenuCategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [MenuCategoryScalarWhereInput!]
  OR: [MenuCategoryScalarWhereInput!]
  NOT: [MenuCategoryScalarWhereInput!]
}

type MenuCategorySubscriptionPayload {
  mutation: MutationType!
  node: MenuCategory
  updatedFields: [String!]
  previousValues: MenuCategoryPreviousValues
}

input MenuCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuCategoryWhereInput
  AND: [MenuCategorySubscriptionWhereInput!]
  OR: [MenuCategorySubscriptionWhereInput!]
  NOT: [MenuCategorySubscriptionWhereInput!]
}

input MenuCategoryUpdateDataInput {
  name: String
  store: StoreUpdateOneRequiredWithoutMenuCategoryListInput
}

input MenuCategoryUpdateInput {
  name: String
  store: StoreUpdateOneRequiredWithoutMenuCategoryListInput
}

input MenuCategoryUpdateManyDataInput {
  name: String
}

input MenuCategoryUpdateManyMutationInput {
  name: String
}

input MenuCategoryUpdateManyWithoutStoreInput {
  create: [MenuCategoryCreateWithoutStoreInput!]
  delete: [MenuCategoryWhereUniqueInput!]
  connect: [MenuCategoryWhereUniqueInput!]
  set: [MenuCategoryWhereUniqueInput!]
  disconnect: [MenuCategoryWhereUniqueInput!]
  update: [MenuCategoryUpdateWithWhereUniqueWithoutStoreInput!]
  upsert: [MenuCategoryUpsertWithWhereUniqueWithoutStoreInput!]
  deleteMany: [MenuCategoryScalarWhereInput!]
  updateMany: [MenuCategoryUpdateManyWithWhereNestedInput!]
}

input MenuCategoryUpdateManyWithWhereNestedInput {
  where: MenuCategoryScalarWhereInput!
  data: MenuCategoryUpdateManyDataInput!
}

input MenuCategoryUpdateOneRequiredInput {
  create: MenuCategoryCreateInput
  update: MenuCategoryUpdateDataInput
  upsert: MenuCategoryUpsertNestedInput
  connect: MenuCategoryWhereUniqueInput
}

input MenuCategoryUpdateWithoutStoreDataInput {
  name: String
}

input MenuCategoryUpdateWithWhereUniqueWithoutStoreInput {
  where: MenuCategoryWhereUniqueInput!
  data: MenuCategoryUpdateWithoutStoreDataInput!
}

input MenuCategoryUpsertNestedInput {
  update: MenuCategoryUpdateDataInput!
  create: MenuCategoryCreateInput!
}

input MenuCategoryUpsertWithWhereUniqueWithoutStoreInput {
  where: MenuCategoryWhereUniqueInput!
  update: MenuCategoryUpdateWithoutStoreDataInput!
  create: MenuCategoryCreateWithoutStoreInput!
}

input MenuCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  store: StoreWhereInput
  AND: [MenuCategoryWhereInput!]
  OR: [MenuCategoryWhereInput!]
  NOT: [MenuCategoryWhereInput!]
}

input MenuCategoryWhereUniqueInput {
  id: ID
}

type MenuConnection {
  pageInfo: PageInfo!
  edges: [MenuEdge]!
  aggregate: AggregateMenu!
}

input MenuCreateInput {
  id: ID
  name: String!
  store: StoreCreateOneWithoutMenuListInput!
  price: Int!
  menuCategory: MenuCategoryCreateOneInput!
}

input MenuCreateManyInput {
  create: [MenuCreateInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateManyWithoutStoreInput {
  create: [MenuCreateWithoutStoreInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateWithoutStoreInput {
  id: ID
  name: String!
  price: Int!
  menuCategory: MenuCategoryCreateOneInput!
}

type MenuEdge {
  node: Menu!
  cursor: String!
}

enum MenuOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
}

type MenuPreviousValues {
  id: ID!
  name: String!
  price: Int!
}

input MenuScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  AND: [MenuScalarWhereInput!]
  OR: [MenuScalarWhereInput!]
  NOT: [MenuScalarWhereInput!]
}

type MenuSubscriptionPayload {
  mutation: MutationType!
  node: Menu
  updatedFields: [String!]
  previousValues: MenuPreviousValues
}

input MenuSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuWhereInput
  AND: [MenuSubscriptionWhereInput!]
  OR: [MenuSubscriptionWhereInput!]
  NOT: [MenuSubscriptionWhereInput!]
}

input MenuUpdateDataInput {
  name: String
  store: StoreUpdateOneRequiredWithoutMenuListInput
  price: Int
  menuCategory: MenuCategoryUpdateOneRequiredInput
}

input MenuUpdateInput {
  name: String
  store: StoreUpdateOneRequiredWithoutMenuListInput
  price: Int
  menuCategory: MenuCategoryUpdateOneRequiredInput
}

input MenuUpdateManyDataInput {
  name: String
  price: Int
}

input MenuUpdateManyInput {
  create: [MenuCreateInput!]
  update: [MenuUpdateWithWhereUniqueNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueNestedInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyMutationInput {
  name: String
  price: Int
}

input MenuUpdateManyWithoutStoreInput {
  create: [MenuCreateWithoutStoreInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutStoreInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutStoreInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyWithWhereNestedInput {
  where: MenuScalarWhereInput!
  data: MenuUpdateManyDataInput!
}

input MenuUpdateWithoutStoreDataInput {
  name: String
  price: Int
  menuCategory: MenuCategoryUpdateOneRequiredInput
}

input MenuUpdateWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateDataInput!
}

input MenuUpdateWithWhereUniqueWithoutStoreInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateWithoutStoreDataInput!
}

input MenuUpsertWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateDataInput!
  create: MenuCreateInput!
}

input MenuUpsertWithWhereUniqueWithoutStoreInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateWithoutStoreDataInput!
  create: MenuCreateWithoutStoreInput!
}

input MenuWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  store: StoreWhereInput
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  menuCategory: MenuCategoryWhereInput
  AND: [MenuWhereInput!]
  OR: [MenuWhereInput!]
  NOT: [MenuWhereInput!]
}

input MenuWhereUniqueInput {
  id: ID
}

type Mutation {
  createChatContent(data: ChatContentCreateInput!): ChatContent!
  updateChatContent(data: ChatContentUpdateInput!, where: ChatContentWhereUniqueInput!): ChatContent
  updateManyChatContents(data: ChatContentUpdateManyMutationInput!, where: ChatContentWhereInput): BatchPayload!
  upsertChatContent(where: ChatContentWhereUniqueInput!, create: ChatContentCreateInput!, update: ChatContentUpdateInput!): ChatContent!
  deleteChatContent(where: ChatContentWhereUniqueInput!): ChatContent
  deleteManyChatContents(where: ChatContentWhereInput): BatchPayload!
  createChatRoom(data: ChatRoomCreateInput!): ChatRoom!
  updateChatRoom(data: ChatRoomUpdateInput!, where: ChatRoomWhereUniqueInput!): ChatRoom
  updateManyChatRooms(data: ChatRoomUpdateManyMutationInput!, where: ChatRoomWhereInput): BatchPayload!
  upsertChatRoom(where: ChatRoomWhereUniqueInput!, create: ChatRoomCreateInput!, update: ChatRoomUpdateInput!): ChatRoom!
  deleteChatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  deleteManyChatRooms(where: ChatRoomWhereInput): BatchPayload!
  createIndividualOrder(data: IndividualOrderCreateInput!): IndividualOrder!
  updateIndividualOrder(data: IndividualOrderUpdateInput!, where: IndividualOrderWhereUniqueInput!): IndividualOrder
  upsertIndividualOrder(where: IndividualOrderWhereUniqueInput!, create: IndividualOrderCreateInput!, update: IndividualOrderUpdateInput!): IndividualOrder!
  deleteIndividualOrder(where: IndividualOrderWhereUniqueInput!): IndividualOrder
  deleteManyIndividualOrders(where: IndividualOrderWhereInput): BatchPayload!
  createMenu(data: MenuCreateInput!): Menu!
  updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateManyMenus(data: MenuUpdateManyMutationInput!, where: MenuWhereInput): BatchPayload!
  upsertMenu(where: MenuWhereUniqueInput!, create: MenuCreateInput!, update: MenuUpdateInput!): Menu!
  deleteMenu(where: MenuWhereUniqueInput!): Menu
  deleteManyMenus(where: MenuWhereInput): BatchPayload!
  createMenuCategory(data: MenuCategoryCreateInput!): MenuCategory!
  updateMenuCategory(data: MenuCategoryUpdateInput!, where: MenuCategoryWhereUniqueInput!): MenuCategory
  updateManyMenuCategories(data: MenuCategoryUpdateManyMutationInput!, where: MenuCategoryWhereInput): BatchPayload!
  upsertMenuCategory(where: MenuCategoryWhereUniqueInput!, create: MenuCategoryCreateInput!, update: MenuCategoryUpdateInput!): MenuCategory!
  deleteMenuCategory(where: MenuCategoryWhereUniqueInput!): MenuCategory
  deleteManyMenuCategories(where: MenuCategoryWhereInput): BatchPayload!
  createRoomOrder(data: RoomOrderCreateInput!): RoomOrder!
  updateRoomOrder(data: RoomOrderUpdateInput!, where: RoomOrderWhereUniqueInput!): RoomOrder
  updateManyRoomOrders(data: RoomOrderUpdateManyMutationInput!, where: RoomOrderWhereInput): BatchPayload!
  upsertRoomOrder(where: RoomOrderWhereUniqueInput!, create: RoomOrderCreateInput!, update: RoomOrderUpdateInput!): RoomOrder!
  deleteRoomOrder(where: RoomOrderWhereUniqueInput!): RoomOrder
  deleteManyRoomOrders(where: RoomOrderWhereInput): BatchPayload!
  createStore(data: StoreCreateInput!): Store!
  updateStore(data: StoreUpdateInput!, where: StoreWhereUniqueInput!): Store
  updateManyStores(data: StoreUpdateManyMutationInput!, where: StoreWhereInput): BatchPayload!
  upsertStore(where: StoreWhereUniqueInput!, create: StoreCreateInput!, update: StoreUpdateInput!): Store!
  deleteStore(where: StoreWhereUniqueInput!): Store
  deleteManyStores(where: StoreWhereInput): BatchPayload!
  createStoreCategory(data: StoreCategoryCreateInput!): StoreCategory!
  updateStoreCategory(data: StoreCategoryUpdateInput!, where: StoreCategoryWhereUniqueInput!): StoreCategory
  updateManyStoreCategories(data: StoreCategoryUpdateManyMutationInput!, where: StoreCategoryWhereInput): BatchPayload!
  upsertStoreCategory(where: StoreCategoryWhereUniqueInput!, create: StoreCategoryCreateInput!, update: StoreCategoryUpdateInput!): StoreCategory!
  deleteStoreCategory(where: StoreCategoryWhereUniqueInput!): StoreCategory
  deleteManyStoreCategories(where: StoreCategoryWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  chatContent(where: ChatContentWhereUniqueInput!): ChatContent
  chatContents(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatContent]!
  chatContentsConnection(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatContentConnection!
  chatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  chatRooms(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom]!
  chatRoomsConnection(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatRoomConnection!
  individualOrder(where: IndividualOrderWhereUniqueInput!): IndividualOrder
  individualOrders(where: IndividualOrderWhereInput, orderBy: IndividualOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IndividualOrder]!
  individualOrdersConnection(where: IndividualOrderWhereInput, orderBy: IndividualOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IndividualOrderConnection!
  menu(where: MenuWhereUniqueInput!): Menu
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu]!
  menusConnection(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuConnection!
  menuCategory(where: MenuCategoryWhereUniqueInput!): MenuCategory
  menuCategories(where: MenuCategoryWhereInput, orderBy: MenuCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuCategory]!
  menuCategoriesConnection(where: MenuCategoryWhereInput, orderBy: MenuCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuCategoryConnection!
  roomOrder(where: RoomOrderWhereUniqueInput!): RoomOrder
  roomOrders(where: RoomOrderWhereInput, orderBy: RoomOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RoomOrder]!
  roomOrdersConnection(where: RoomOrderWhereInput, orderBy: RoomOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomOrderConnection!
  store(where: StoreWhereUniqueInput!): Store
  stores(where: StoreWhereInput, orderBy: StoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Store]!
  storesConnection(where: StoreWhereInput, orderBy: StoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StoreConnection!
  storeCategory(where: StoreCategoryWhereUniqueInput!): StoreCategory
  storeCategories(where: StoreCategoryWhereInput, orderBy: StoreCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StoreCategory]!
  storeCategoriesConnection(where: StoreCategoryWhereInput, orderBy: StoreCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StoreCategoryConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type RoomOrder {
  id: ID!
  chatRoom: ChatRoom!
  individualOrderList(where: IndividualOrderWhereInput, orderBy: IndividualOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IndividualOrder!]
  phoneNumber: String!
  state: Boolean!
}

type RoomOrderConnection {
  pageInfo: PageInfo!
  edges: [RoomOrderEdge]!
  aggregate: AggregateRoomOrder!
}

input RoomOrderCreateInput {
  id: ID
  chatRoom: ChatRoomCreateOneInput!
  individualOrderList: IndividualOrderCreateManyInput
  phoneNumber: String!
  state: Boolean!
}

input RoomOrderCreateManyInput {
  create: [RoomOrderCreateInput!]
  connect: [RoomOrderWhereUniqueInput!]
}

type RoomOrderEdge {
  node: RoomOrder!
  cursor: String!
}

enum RoomOrderOrderByInput {
  id_ASC
  id_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  state_ASC
  state_DESC
}

type RoomOrderPreviousValues {
  id: ID!
  phoneNumber: String!
  state: Boolean!
}

input RoomOrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  state: Boolean
  state_not: Boolean
  AND: [RoomOrderScalarWhereInput!]
  OR: [RoomOrderScalarWhereInput!]
  NOT: [RoomOrderScalarWhereInput!]
}

type RoomOrderSubscriptionPayload {
  mutation: MutationType!
  node: RoomOrder
  updatedFields: [String!]
  previousValues: RoomOrderPreviousValues
}

input RoomOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomOrderWhereInput
  AND: [RoomOrderSubscriptionWhereInput!]
  OR: [RoomOrderSubscriptionWhereInput!]
  NOT: [RoomOrderSubscriptionWhereInput!]
}

input RoomOrderUpdateDataInput {
  chatRoom: ChatRoomUpdateOneRequiredInput
  individualOrderList: IndividualOrderUpdateManyInput
  phoneNumber: String
  state: Boolean
}

input RoomOrderUpdateInput {
  chatRoom: ChatRoomUpdateOneRequiredInput
  individualOrderList: IndividualOrderUpdateManyInput
  phoneNumber: String
  state: Boolean
}

input RoomOrderUpdateManyDataInput {
  phoneNumber: String
  state: Boolean
}

input RoomOrderUpdateManyInput {
  create: [RoomOrderCreateInput!]
  update: [RoomOrderUpdateWithWhereUniqueNestedInput!]
  upsert: [RoomOrderUpsertWithWhereUniqueNestedInput!]
  delete: [RoomOrderWhereUniqueInput!]
  connect: [RoomOrderWhereUniqueInput!]
  set: [RoomOrderWhereUniqueInput!]
  disconnect: [RoomOrderWhereUniqueInput!]
  deleteMany: [RoomOrderScalarWhereInput!]
  updateMany: [RoomOrderUpdateManyWithWhereNestedInput!]
}

input RoomOrderUpdateManyMutationInput {
  phoneNumber: String
  state: Boolean
}

input RoomOrderUpdateManyWithWhereNestedInput {
  where: RoomOrderScalarWhereInput!
  data: RoomOrderUpdateManyDataInput!
}

input RoomOrderUpdateWithWhereUniqueNestedInput {
  where: RoomOrderWhereUniqueInput!
  data: RoomOrderUpdateDataInput!
}

input RoomOrderUpsertWithWhereUniqueNestedInput {
  where: RoomOrderWhereUniqueInput!
  update: RoomOrderUpdateDataInput!
  create: RoomOrderCreateInput!
}

input RoomOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  chatRoom: ChatRoomWhereInput
  individualOrderList_every: IndividualOrderWhereInput
  individualOrderList_some: IndividualOrderWhereInput
  individualOrderList_none: IndividualOrderWhereInput
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  state: Boolean
  state_not: Boolean
  AND: [RoomOrderWhereInput!]
  OR: [RoomOrderWhereInput!]
  NOT: [RoomOrderWhereInput!]
}

input RoomOrderWhereUniqueInput {
  id: ID
}

type Store {
  id: ID!
  storeId: String!
  pwd: String!
  name: String!
  storeCategory: StoreCategory!
  menuCategoryList(where: MenuCategoryWhereInput, orderBy: MenuCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuCategory!]
  menuList(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
  roomOrderList(where: RoomOrderWhereInput, orderBy: RoomOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RoomOrder!]
}

type StoreCategory {
  id: ID!
  name: String!
}

type StoreCategoryConnection {
  pageInfo: PageInfo!
  edges: [StoreCategoryEdge]!
  aggregate: AggregateStoreCategory!
}

input StoreCategoryCreateInput {
  id: ID
  name: String!
}

input StoreCategoryCreateOneInput {
  create: StoreCategoryCreateInput
  connect: StoreCategoryWhereUniqueInput
}

type StoreCategoryEdge {
  node: StoreCategory!
  cursor: String!
}

enum StoreCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type StoreCategoryPreviousValues {
  id: ID!
  name: String!
}

type StoreCategorySubscriptionPayload {
  mutation: MutationType!
  node: StoreCategory
  updatedFields: [String!]
  previousValues: StoreCategoryPreviousValues
}

input StoreCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StoreCategoryWhereInput
  AND: [StoreCategorySubscriptionWhereInput!]
  OR: [StoreCategorySubscriptionWhereInput!]
  NOT: [StoreCategorySubscriptionWhereInput!]
}

input StoreCategoryUpdateDataInput {
  name: String
}

input StoreCategoryUpdateInput {
  name: String
}

input StoreCategoryUpdateManyMutationInput {
  name: String
}

input StoreCategoryUpdateOneRequiredInput {
  create: StoreCategoryCreateInput
  update: StoreCategoryUpdateDataInput
  upsert: StoreCategoryUpsertNestedInput
  connect: StoreCategoryWhereUniqueInput
}

input StoreCategoryUpsertNestedInput {
  update: StoreCategoryUpdateDataInput!
  create: StoreCategoryCreateInput!
}

input StoreCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [StoreCategoryWhereInput!]
  OR: [StoreCategoryWhereInput!]
  NOT: [StoreCategoryWhereInput!]
}

input StoreCategoryWhereUniqueInput {
  id: ID
}

type StoreConnection {
  pageInfo: PageInfo!
  edges: [StoreEdge]!
  aggregate: AggregateStore!
}

input StoreCreateInput {
  id: ID
  storeId: String!
  pwd: String!
  name: String!
  storeCategory: StoreCategoryCreateOneInput!
  menuCategoryList: MenuCategoryCreateManyWithoutStoreInput
  menuList: MenuCreateManyWithoutStoreInput
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
  roomOrderList: RoomOrderCreateManyInput
}

input StoreCreateOneInput {
  create: StoreCreateInput
  connect: StoreWhereUniqueInput
}

input StoreCreateOneWithoutMenuCategoryListInput {
  create: StoreCreateWithoutMenuCategoryListInput
  connect: StoreWhereUniqueInput
}

input StoreCreateOneWithoutMenuListInput {
  create: StoreCreateWithoutMenuListInput
  connect: StoreWhereUniqueInput
}

input StoreCreateWithoutMenuCategoryListInput {
  id: ID
  storeId: String!
  pwd: String!
  name: String!
  storeCategory: StoreCategoryCreateOneInput!
  menuList: MenuCreateManyWithoutStoreInput
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
  roomOrderList: RoomOrderCreateManyInput
}

input StoreCreateWithoutMenuListInput {
  id: ID
  storeId: String!
  pwd: String!
  name: String!
  storeCategory: StoreCategoryCreateOneInput!
  menuCategoryList: MenuCategoryCreateManyWithoutStoreInput
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
  roomOrderList: RoomOrderCreateManyInput
}

type StoreEdge {
  node: Store!
  cursor: String!
}

enum StoreOrderByInput {
  id_ASC
  id_DESC
  storeId_ASC
  storeId_DESC
  pwd_ASC
  pwd_DESC
  name_ASC
  name_DESC
  minimumPrice_ASC
  minimumPrice_DESC
  deliveryFee_ASC
  deliveryFee_DESC
  image_ASC
  image_DESC
}

type StorePreviousValues {
  id: ID!
  storeId: String!
  pwd: String!
  name: String!
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
}

type StoreSubscriptionPayload {
  mutation: MutationType!
  node: Store
  updatedFields: [String!]
  previousValues: StorePreviousValues
}

input StoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StoreWhereInput
  AND: [StoreSubscriptionWhereInput!]
  OR: [StoreSubscriptionWhereInput!]
  NOT: [StoreSubscriptionWhereInput!]
}

input StoreUpdateDataInput {
  storeId: String
  pwd: String
  name: String
  storeCategory: StoreCategoryUpdateOneRequiredInput
  menuCategoryList: MenuCategoryUpdateManyWithoutStoreInput
  menuList: MenuUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  image: String
  roomOrderList: RoomOrderUpdateManyInput
}

input StoreUpdateInput {
  storeId: String
  pwd: String
  name: String
  storeCategory: StoreCategoryUpdateOneRequiredInput
  menuCategoryList: MenuCategoryUpdateManyWithoutStoreInput
  menuList: MenuUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  image: String
  roomOrderList: RoomOrderUpdateManyInput
}

input StoreUpdateManyMutationInput {
  storeId: String
  pwd: String
  name: String
  minimumPrice: Int
  deliveryFee: Int
  image: String
}

input StoreUpdateOneRequiredInput {
  create: StoreCreateInput
  update: StoreUpdateDataInput
  upsert: StoreUpsertNestedInput
  connect: StoreWhereUniqueInput
}

input StoreUpdateOneRequiredWithoutMenuCategoryListInput {
  create: StoreCreateWithoutMenuCategoryListInput
  update: StoreUpdateWithoutMenuCategoryListDataInput
  upsert: StoreUpsertWithoutMenuCategoryListInput
  connect: StoreWhereUniqueInput
}

input StoreUpdateOneRequiredWithoutMenuListInput {
  create: StoreCreateWithoutMenuListInput
  update: StoreUpdateWithoutMenuListDataInput
  upsert: StoreUpsertWithoutMenuListInput
  connect: StoreWhereUniqueInput
}

input StoreUpdateWithoutMenuCategoryListDataInput {
  storeId: String
  pwd: String
  name: String
  storeCategory: StoreCategoryUpdateOneRequiredInput
  menuList: MenuUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  image: String
  roomOrderList: RoomOrderUpdateManyInput
}

input StoreUpdateWithoutMenuListDataInput {
  storeId: String
  pwd: String
  name: String
  storeCategory: StoreCategoryUpdateOneRequiredInput
  menuCategoryList: MenuCategoryUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  image: String
  roomOrderList: RoomOrderUpdateManyInput
}

input StoreUpsertNestedInput {
  update: StoreUpdateDataInput!
  create: StoreCreateInput!
}

input StoreUpsertWithoutMenuCategoryListInput {
  update: StoreUpdateWithoutMenuCategoryListDataInput!
  create: StoreCreateWithoutMenuCategoryListInput!
}

input StoreUpsertWithoutMenuListInput {
  update: StoreUpdateWithoutMenuListDataInput!
  create: StoreCreateWithoutMenuListInput!
}

input StoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  storeId: String
  storeId_not: String
  storeId_in: [String!]
  storeId_not_in: [String!]
  storeId_lt: String
  storeId_lte: String
  storeId_gt: String
  storeId_gte: String
  storeId_contains: String
  storeId_not_contains: String
  storeId_starts_with: String
  storeId_not_starts_with: String
  storeId_ends_with: String
  storeId_not_ends_with: String
  pwd: String
  pwd_not: String
  pwd_in: [String!]
  pwd_not_in: [String!]
  pwd_lt: String
  pwd_lte: String
  pwd_gt: String
  pwd_gte: String
  pwd_contains: String
  pwd_not_contains: String
  pwd_starts_with: String
  pwd_not_starts_with: String
  pwd_ends_with: String
  pwd_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  storeCategory: StoreCategoryWhereInput
  menuCategoryList_every: MenuCategoryWhereInput
  menuCategoryList_some: MenuCategoryWhereInput
  menuCategoryList_none: MenuCategoryWhereInput
  menuList_every: MenuWhereInput
  menuList_some: MenuWhereInput
  menuList_none: MenuWhereInput
  minimumPrice: Int
  minimumPrice_not: Int
  minimumPrice_in: [Int!]
  minimumPrice_not_in: [Int!]
  minimumPrice_lt: Int
  minimumPrice_lte: Int
  minimumPrice_gt: Int
  minimumPrice_gte: Int
  deliveryFee: Int
  deliveryFee_not: Int
  deliveryFee_in: [Int!]
  deliveryFee_not_in: [Int!]
  deliveryFee_lt: Int
  deliveryFee_lte: Int
  deliveryFee_gt: Int
  deliveryFee_gte: Int
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  roomOrderList_every: RoomOrderWhereInput
  roomOrderList_some: RoomOrderWhereInput
  roomOrderList_none: RoomOrderWhereInput
  AND: [StoreWhereInput!]
  OR: [StoreWhereInput!]
  NOT: [StoreWhereInput!]
}

input StoreWhereUniqueInput {
  id: ID
}

type Subscription {
  chatContent(where: ChatContentSubscriptionWhereInput): ChatContentSubscriptionPayload
  chatRoom(where: ChatRoomSubscriptionWhereInput): ChatRoomSubscriptionPayload
  individualOrder(where: IndividualOrderSubscriptionWhereInput): IndividualOrderSubscriptionPayload
  menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
  menuCategory(where: MenuCategorySubscriptionWhereInput): MenuCategorySubscriptionPayload
  roomOrder(where: RoomOrderSubscriptionWhereInput): RoomOrderSubscriptionPayload
  store(where: StoreSubscriptionWhereInput): StoreSubscriptionPayload
  storeCategory(where: StoreCategorySubscriptionWhereInput): StoreCategorySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  number: Int!
  pwd: String!
  score: Int!
  chatList(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  number: Int!
  pwd: String!
  score: Int
  chatList: ChatRoomCreateManyWithoutBossInput
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutChatListInput {
  create: UserCreateWithoutChatListInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutChatListInput {
  id: ID
  number: Int!
  pwd: String!
  score: Int
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  number_ASC
  number_DESC
  pwd_ASC
  pwd_DESC
  score_ASC
  score_DESC
}

type UserPreviousValues {
  id: ID!
  number: Int!
  pwd: String!
  score: Int!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  pwd: String
  pwd_not: String
  pwd_in: [String!]
  pwd_not_in: [String!]
  pwd_lt: String
  pwd_lte: String
  pwd_gt: String
  pwd_gte: String
  pwd_contains: String
  pwd_not_contains: String
  pwd_starts_with: String
  pwd_not_starts_with: String
  pwd_ends_with: String
  pwd_not_ends_with: String
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  number: Int
  pwd: String
  score: Int
  chatList: ChatRoomUpdateManyWithoutBossInput
}

input UserUpdateInput {
  number: Int
  pwd: String
  score: Int
  chatList: ChatRoomUpdateManyWithoutBossInput
}

input UserUpdateManyDataInput {
  number: Int
  pwd: String
  score: Int
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  number: Int
  pwd: String
  score: Int
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutChatListInput {
  create: UserCreateWithoutChatListInput
  update: UserUpdateWithoutChatListDataInput
  upsert: UserUpsertWithoutChatListInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutChatListDataInput {
  number: Int
  pwd: String
  score: Int
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutChatListInput {
  update: UserUpdateWithoutChatListDataInput!
  create: UserCreateWithoutChatListInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  pwd: String
  pwd_not: String
  pwd_in: [String!]
  pwd_not_in: [String!]
  pwd_lt: String
  pwd_lte: String
  pwd_gt: String
  pwd_gte: String
  pwd_contains: String
  pwd_not_contains: String
  pwd_starts_with: String
  pwd_not_starts_with: String
  pwd_ends_with: String
  pwd_not_ends_with: String
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  chatList_every: ChatRoomWhereInput
  chatList_some: ChatRoomWhereInput
  chatList_none: ChatRoomWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    