module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCategory {
  count: Int!
}

type AggregateChatContent {
  count: Int!
}

type AggregateChatRoom {
  count: Int!
}

type AggregateMenu {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateStore {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Category {
  id: ID!
  name: String!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  name: String!
}

input CategoryCreateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
  name: String
}

input CategoryUpdateInput {
  name: String
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryUpdateOneRequiredInput {
  create: CategoryCreateInput
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

type ChatContent {
  id: ID!
  user: User!
  chatRoom: ChatRoom!
  content: String!
}

type ChatContentConnection {
  pageInfo: PageInfo!
  edges: [ChatContentEdge]!
  aggregate: AggregateChatContent!
}

input ChatContentCreateInput {
  id: ID
  user: UserCreateOneInput!
  chatRoom: ChatRoomCreateOneWithoutChatContentListInput!
  content: String!
}

input ChatContentCreateManyWithoutChatRoomInput {
  create: [ChatContentCreateWithoutChatRoomInput!]
  connect: [ChatContentWhereUniqueInput!]
}

input ChatContentCreateWithoutChatRoomInput {
  id: ID
  user: UserCreateOneInput!
  content: String!
}

type ChatContentEdge {
  node: ChatContent!
  cursor: String!
}

enum ChatContentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
}

type ChatContentPreviousValues {
  id: ID!
  content: String!
}

input ChatContentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [ChatContentScalarWhereInput!]
  OR: [ChatContentScalarWhereInput!]
  NOT: [ChatContentScalarWhereInput!]
}

type ChatContentSubscriptionPayload {
  mutation: MutationType!
  node: ChatContent
  updatedFields: [String!]
  previousValues: ChatContentPreviousValues
}

input ChatContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatContentWhereInput
  AND: [ChatContentSubscriptionWhereInput!]
  OR: [ChatContentSubscriptionWhereInput!]
  NOT: [ChatContentSubscriptionWhereInput!]
}

input ChatContentUpdateInput {
  user: UserUpdateOneRequiredInput
  chatRoom: ChatRoomUpdateOneRequiredWithoutChatContentListInput
  content: String
}

input ChatContentUpdateManyDataInput {
  content: String
}

input ChatContentUpdateManyMutationInput {
  content: String
}

input ChatContentUpdateManyWithoutChatRoomInput {
  create: [ChatContentCreateWithoutChatRoomInput!]
  delete: [ChatContentWhereUniqueInput!]
  connect: [ChatContentWhereUniqueInput!]
  set: [ChatContentWhereUniqueInput!]
  disconnect: [ChatContentWhereUniqueInput!]
  update: [ChatContentUpdateWithWhereUniqueWithoutChatRoomInput!]
  upsert: [ChatContentUpsertWithWhereUniqueWithoutChatRoomInput!]
  deleteMany: [ChatContentScalarWhereInput!]
  updateMany: [ChatContentUpdateManyWithWhereNestedInput!]
}

input ChatContentUpdateManyWithWhereNestedInput {
  where: ChatContentScalarWhereInput!
  data: ChatContentUpdateManyDataInput!
}

input ChatContentUpdateWithoutChatRoomDataInput {
  user: UserUpdateOneRequiredInput
  content: String
}

input ChatContentUpdateWithWhereUniqueWithoutChatRoomInput {
  where: ChatContentWhereUniqueInput!
  data: ChatContentUpdateWithoutChatRoomDataInput!
}

input ChatContentUpsertWithWhereUniqueWithoutChatRoomInput {
  where: ChatContentWhereUniqueInput!
  update: ChatContentUpdateWithoutChatRoomDataInput!
  create: ChatContentCreateWithoutChatRoomInput!
}

input ChatContentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  chatRoom: ChatRoomWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [ChatContentWhereInput!]
  OR: [ChatContentWhereInput!]
  NOT: [ChatContentWhereInput!]
}

input ChatContentWhereUniqueInput {
  id: ID
}

type ChatRoom {
  id: ID!
  boss: User!
  memberList(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  store: Store!
  location: String!
  orderExpectedTime: DateTime!
  orderList(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  chatContentList(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatContent!]
  state: Boolean!
}

type ChatRoomConnection {
  pageInfo: PageInfo!
  edges: [ChatRoomEdge]!
  aggregate: AggregateChatRoom!
}

input ChatRoomCreateInput {
  id: ID
  boss: UserCreateOneWithoutChatListInput!
  memberList: UserCreateManyInput
  store: StoreCreateOneInput!
  location: String!
  orderExpectedTime: DateTime!
  orderList: OrderCreateManyWithoutChatRoomInput
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateManyWithoutBossInput {
  create: [ChatRoomCreateWithoutBossInput!]
  connect: [ChatRoomWhereUniqueInput!]
}

input ChatRoomCreateOneWithoutChatContentListInput {
  create: ChatRoomCreateWithoutChatContentListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateOneWithoutOrderListInput {
  create: ChatRoomCreateWithoutOrderListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateWithoutBossInput {
  id: ID
  memberList: UserCreateManyInput
  store: StoreCreateOneInput!
  location: String!
  orderExpectedTime: DateTime!
  orderList: OrderCreateManyWithoutChatRoomInput
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateWithoutChatContentListInput {
  id: ID
  boss: UserCreateOneWithoutChatListInput!
  memberList: UserCreateManyInput
  store: StoreCreateOneInput!
  location: String!
  orderExpectedTime: DateTime!
  orderList: OrderCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateWithoutOrderListInput {
  id: ID
  boss: UserCreateOneWithoutChatListInput!
  memberList: UserCreateManyInput
  store: StoreCreateOneInput!
  location: String!
  orderExpectedTime: DateTime!
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

type ChatRoomEdge {
  node: ChatRoom!
  cursor: String!
}

enum ChatRoomOrderByInput {
  id_ASC
  id_DESC
  location_ASC
  location_DESC
  orderExpectedTime_ASC
  orderExpectedTime_DESC
  state_ASC
  state_DESC
}

type ChatRoomPreviousValues {
  id: ID!
  location: String!
  orderExpectedTime: DateTime!
  state: Boolean!
}

input ChatRoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  orderExpectedTime: DateTime
  orderExpectedTime_not: DateTime
  orderExpectedTime_in: [DateTime!]
  orderExpectedTime_not_in: [DateTime!]
  orderExpectedTime_lt: DateTime
  orderExpectedTime_lte: DateTime
  orderExpectedTime_gt: DateTime
  orderExpectedTime_gte: DateTime
  state: Boolean
  state_not: Boolean
  AND: [ChatRoomScalarWhereInput!]
  OR: [ChatRoomScalarWhereInput!]
  NOT: [ChatRoomScalarWhereInput!]
}

type ChatRoomSubscriptionPayload {
  mutation: MutationType!
  node: ChatRoom
  updatedFields: [String!]
  previousValues: ChatRoomPreviousValues
}

input ChatRoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatRoomWhereInput
  AND: [ChatRoomSubscriptionWhereInput!]
  OR: [ChatRoomSubscriptionWhereInput!]
  NOT: [ChatRoomSubscriptionWhereInput!]
}

input ChatRoomUpdateInput {
  boss: UserUpdateOneRequiredWithoutChatListInput
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  orderList: OrderUpdateManyWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateManyDataInput {
  location: String
  orderExpectedTime: DateTime
  state: Boolean
}

input ChatRoomUpdateManyMutationInput {
  location: String
  orderExpectedTime: DateTime
  state: Boolean
}

input ChatRoomUpdateManyWithoutBossInput {
  create: [ChatRoomCreateWithoutBossInput!]
  delete: [ChatRoomWhereUniqueInput!]
  connect: [ChatRoomWhereUniqueInput!]
  set: [ChatRoomWhereUniqueInput!]
  disconnect: [ChatRoomWhereUniqueInput!]
  update: [ChatRoomUpdateWithWhereUniqueWithoutBossInput!]
  upsert: [ChatRoomUpsertWithWhereUniqueWithoutBossInput!]
  deleteMany: [ChatRoomScalarWhereInput!]
  updateMany: [ChatRoomUpdateManyWithWhereNestedInput!]
}

input ChatRoomUpdateManyWithWhereNestedInput {
  where: ChatRoomScalarWhereInput!
  data: ChatRoomUpdateManyDataInput!
}

input ChatRoomUpdateOneRequiredWithoutChatContentListInput {
  create: ChatRoomCreateWithoutChatContentListInput
  update: ChatRoomUpdateWithoutChatContentListDataInput
  upsert: ChatRoomUpsertWithoutChatContentListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateOneRequiredWithoutOrderListInput {
  create: ChatRoomCreateWithoutOrderListInput
  update: ChatRoomUpdateWithoutOrderListDataInput
  upsert: ChatRoomUpsertWithoutOrderListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateWithoutBossDataInput {
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  orderList: OrderUpdateManyWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithoutChatContentListDataInput {
  boss: UserUpdateOneRequiredWithoutChatListInput
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  orderList: OrderUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithoutOrderListDataInput {
  boss: UserUpdateOneRequiredWithoutChatListInput
  memberList: UserUpdateManyInput
  store: StoreUpdateOneRequiredInput
  location: String
  orderExpectedTime: DateTime
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithWhereUniqueWithoutBossInput {
  where: ChatRoomWhereUniqueInput!
  data: ChatRoomUpdateWithoutBossDataInput!
}

input ChatRoomUpsertWithoutChatContentListInput {
  update: ChatRoomUpdateWithoutChatContentListDataInput!
  create: ChatRoomCreateWithoutChatContentListInput!
}

input ChatRoomUpsertWithoutOrderListInput {
  update: ChatRoomUpdateWithoutOrderListDataInput!
  create: ChatRoomCreateWithoutOrderListInput!
}

input ChatRoomUpsertWithWhereUniqueWithoutBossInput {
  where: ChatRoomWhereUniqueInput!
  update: ChatRoomUpdateWithoutBossDataInput!
  create: ChatRoomCreateWithoutBossInput!
}

input ChatRoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  boss: UserWhereInput
  memberList_every: UserWhereInput
  memberList_some: UserWhereInput
  memberList_none: UserWhereInput
  store: StoreWhereInput
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  orderExpectedTime: DateTime
  orderExpectedTime_not: DateTime
  orderExpectedTime_in: [DateTime!]
  orderExpectedTime_not_in: [DateTime!]
  orderExpectedTime_lt: DateTime
  orderExpectedTime_lte: DateTime
  orderExpectedTime_gt: DateTime
  orderExpectedTime_gte: DateTime
  orderList_every: OrderWhereInput
  orderList_some: OrderWhereInput
  orderList_none: OrderWhereInput
  chatContentList_every: ChatContentWhereInput
  chatContentList_some: ChatContentWhereInput
  chatContentList_none: ChatContentWhereInput
  state: Boolean
  state_not: Boolean
  AND: [ChatRoomWhereInput!]
  OR: [ChatRoomWhereInput!]
  NOT: [ChatRoomWhereInput!]
}

input ChatRoomWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Menu {
  id: ID!
  name: String!
  store: Store!
  price: Int!
}

type MenuConnection {
  pageInfo: PageInfo!
  edges: [MenuEdge]!
  aggregate: AggregateMenu!
}

input MenuCreateInput {
  id: ID
  name: String!
  store: StoreCreateOneWithoutMenuListInput!
  price: Int!
}

input MenuCreateManyInput {
  create: [MenuCreateInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateManyWithoutStoreInput {
  create: [MenuCreateWithoutStoreInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateWithoutStoreInput {
  id: ID
  name: String!
  price: Int!
}

type MenuEdge {
  node: Menu!
  cursor: String!
}

enum MenuOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
}

type MenuPreviousValues {
  id: ID!
  name: String!
  price: Int!
}

input MenuScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  AND: [MenuScalarWhereInput!]
  OR: [MenuScalarWhereInput!]
  NOT: [MenuScalarWhereInput!]
}

type MenuSubscriptionPayload {
  mutation: MutationType!
  node: Menu
  updatedFields: [String!]
  previousValues: MenuPreviousValues
}

input MenuSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuWhereInput
  AND: [MenuSubscriptionWhereInput!]
  OR: [MenuSubscriptionWhereInput!]
  NOT: [MenuSubscriptionWhereInput!]
}

input MenuUpdateDataInput {
  name: String
  store: StoreUpdateOneRequiredWithoutMenuListInput
  price: Int
}

input MenuUpdateInput {
  name: String
  store: StoreUpdateOneRequiredWithoutMenuListInput
  price: Int
}

input MenuUpdateManyDataInput {
  name: String
  price: Int
}

input MenuUpdateManyInput {
  create: [MenuCreateInput!]
  update: [MenuUpdateWithWhereUniqueNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueNestedInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyMutationInput {
  name: String
  price: Int
}

input MenuUpdateManyWithoutStoreInput {
  create: [MenuCreateWithoutStoreInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutStoreInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutStoreInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyWithWhereNestedInput {
  where: MenuScalarWhereInput!
  data: MenuUpdateManyDataInput!
}

input MenuUpdateWithoutStoreDataInput {
  name: String
  price: Int
}

input MenuUpdateWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateDataInput!
}

input MenuUpdateWithWhereUniqueWithoutStoreInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateWithoutStoreDataInput!
}

input MenuUpsertWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateDataInput!
  create: MenuCreateInput!
}

input MenuUpsertWithWhereUniqueWithoutStoreInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateWithoutStoreDataInput!
  create: MenuCreateWithoutStoreInput!
}

input MenuWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  store: StoreWhereInput
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  AND: [MenuWhereInput!]
  OR: [MenuWhereInput!]
  NOT: [MenuWhereInput!]
}

input MenuWhereUniqueInput {
  id: ID
}

type Mutation {
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createChatContent(data: ChatContentCreateInput!): ChatContent!
  updateChatContent(data: ChatContentUpdateInput!, where: ChatContentWhereUniqueInput!): ChatContent
  updateManyChatContents(data: ChatContentUpdateManyMutationInput!, where: ChatContentWhereInput): BatchPayload!
  upsertChatContent(where: ChatContentWhereUniqueInput!, create: ChatContentCreateInput!, update: ChatContentUpdateInput!): ChatContent!
  deleteChatContent(where: ChatContentWhereUniqueInput!): ChatContent
  deleteManyChatContents(where: ChatContentWhereInput): BatchPayload!
  createChatRoom(data: ChatRoomCreateInput!): ChatRoom!
  updateChatRoom(data: ChatRoomUpdateInput!, where: ChatRoomWhereUniqueInput!): ChatRoom
  updateManyChatRooms(data: ChatRoomUpdateManyMutationInput!, where: ChatRoomWhereInput): BatchPayload!
  upsertChatRoom(where: ChatRoomWhereUniqueInput!, create: ChatRoomCreateInput!, update: ChatRoomUpdateInput!): ChatRoom!
  deleteChatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  deleteManyChatRooms(where: ChatRoomWhereInput): BatchPayload!
  createMenu(data: MenuCreateInput!): Menu!
  updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateManyMenus(data: MenuUpdateManyMutationInput!, where: MenuWhereInput): BatchPayload!
  upsertMenu(where: MenuWhereUniqueInput!, create: MenuCreateInput!, update: MenuUpdateInput!): Menu!
  deleteMenu(where: MenuWhereUniqueInput!): Menu
  deleteManyMenus(where: MenuWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createStore(data: StoreCreateInput!): Store!
  updateStore(data: StoreUpdateInput!, where: StoreWhereUniqueInput!): Store
  updateManyStores(data: StoreUpdateManyMutationInput!, where: StoreWhereInput): BatchPayload!
  upsertStore(where: StoreWhereUniqueInput!, create: StoreCreateInput!, update: StoreUpdateInput!): Store!
  deleteStore(where: StoreWhereUniqueInput!): Store
  deleteManyStores(where: StoreWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  user: User!
  menuList(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  chatRoom: ChatRoom!
  state: Int!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  user: UserCreateOneInput!
  menuList: MenuCreateManyInput
  chatRoom: ChatRoomCreateOneWithoutOrderListInput!
  state: Int!
}

input OrderCreateManyInput {
  create: [OrderCreateInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateManyWithoutChatRoomInput {
  create: [OrderCreateWithoutChatRoomInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateWithoutChatRoomInput {
  id: ID
  user: UserCreateOneInput!
  menuList: MenuCreateManyInput
  state: Int!
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  state_ASC
  state_DESC
}

type OrderPreviousValues {
  id: ID!
  state: Int!
}

input OrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  state: Int
  state_not: Int
  state_in: [Int!]
  state_not_in: [Int!]
  state_lt: Int
  state_lte: Int
  state_gt: Int
  state_gte: Int
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateDataInput {
  user: UserUpdateOneRequiredInput
  menuList: MenuUpdateManyInput
  chatRoom: ChatRoomUpdateOneRequiredWithoutOrderListInput
  state: Int
}

input OrderUpdateInput {
  user: UserUpdateOneRequiredInput
  menuList: MenuUpdateManyInput
  chatRoom: ChatRoomUpdateOneRequiredWithoutOrderListInput
  state: Int
}

input OrderUpdateManyDataInput {
  state: Int
}

input OrderUpdateManyInput {
  create: [OrderCreateInput!]
  update: [OrderUpdateWithWhereUniqueNestedInput!]
  upsert: [OrderUpsertWithWhereUniqueNestedInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyMutationInput {
  state: Int
}

input OrderUpdateManyWithoutChatRoomInput {
  create: [OrderCreateWithoutChatRoomInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutChatRoomInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutChatRoomInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateWithoutChatRoomDataInput {
  user: UserUpdateOneRequiredInput
  menuList: MenuUpdateManyInput
  state: Int
}

input OrderUpdateWithWhereUniqueNestedInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateDataInput!
}

input OrderUpdateWithWhereUniqueWithoutChatRoomInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutChatRoomDataInput!
}

input OrderUpsertWithWhereUniqueNestedInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateDataInput!
  create: OrderCreateInput!
}

input OrderUpsertWithWhereUniqueWithoutChatRoomInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutChatRoomDataInput!
  create: OrderCreateWithoutChatRoomInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  menuList_every: MenuWhereInput
  menuList_some: MenuWhereInput
  menuList_none: MenuWhereInput
  chatRoom: ChatRoomWhereInput
  state: Int
  state_not: Int
  state_in: [Int!]
  state_not_in: [Int!]
  state_lt: Int
  state_lte: Int
  state_gt: Int
  state_gte: Int
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  chatContent(where: ChatContentWhereUniqueInput!): ChatContent
  chatContents(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatContent]!
  chatContentsConnection(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatContentConnection!
  chatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  chatRooms(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom]!
  chatRoomsConnection(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatRoomConnection!
  menu(where: MenuWhereUniqueInput!): Menu
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu]!
  menusConnection(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  store(where: StoreWhereUniqueInput!): Store
  stores(where: StoreWhereInput, orderBy: StoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Store]!
  storesConnection(where: StoreWhereInput, orderBy: StoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StoreConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Store {
  id: ID!
  pwd: String!
  category: Category!
  menuList(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  minimumPrice: Int!
  deliveryFee: Int!
  orderList(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
}

type StoreConnection {
  pageInfo: PageInfo!
  edges: [StoreEdge]!
  aggregate: AggregateStore!
}

input StoreCreateInput {
  id: ID
  pwd: String!
  category: CategoryCreateOneInput!
  menuList: MenuCreateManyWithoutStoreInput
  minimumPrice: Int!
  deliveryFee: Int!
  orderList: OrderCreateManyInput
}

input StoreCreateOneInput {
  create: StoreCreateInput
  connect: StoreWhereUniqueInput
}

input StoreCreateOneWithoutMenuListInput {
  create: StoreCreateWithoutMenuListInput
  connect: StoreWhereUniqueInput
}

input StoreCreateWithoutMenuListInput {
  id: ID
  pwd: String!
  category: CategoryCreateOneInput!
  minimumPrice: Int!
  deliveryFee: Int!
  orderList: OrderCreateManyInput
}

type StoreEdge {
  node: Store!
  cursor: String!
}

enum StoreOrderByInput {
  id_ASC
  id_DESC
  pwd_ASC
  pwd_DESC
  minimumPrice_ASC
  minimumPrice_DESC
  deliveryFee_ASC
  deliveryFee_DESC
}

type StorePreviousValues {
  id: ID!
  pwd: String!
  minimumPrice: Int!
  deliveryFee: Int!
}

type StoreSubscriptionPayload {
  mutation: MutationType!
  node: Store
  updatedFields: [String!]
  previousValues: StorePreviousValues
}

input StoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StoreWhereInput
  AND: [StoreSubscriptionWhereInput!]
  OR: [StoreSubscriptionWhereInput!]
  NOT: [StoreSubscriptionWhereInput!]
}

input StoreUpdateDataInput {
  pwd: String
  category: CategoryUpdateOneRequiredInput
  menuList: MenuUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  orderList: OrderUpdateManyInput
}

input StoreUpdateInput {
  pwd: String
  category: CategoryUpdateOneRequiredInput
  menuList: MenuUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  orderList: OrderUpdateManyInput
}

input StoreUpdateManyMutationInput {
  pwd: String
  minimumPrice: Int
  deliveryFee: Int
}

input StoreUpdateOneRequiredInput {
  create: StoreCreateInput
  update: StoreUpdateDataInput
  upsert: StoreUpsertNestedInput
  connect: StoreWhereUniqueInput
}

input StoreUpdateOneRequiredWithoutMenuListInput {
  create: StoreCreateWithoutMenuListInput
  update: StoreUpdateWithoutMenuListDataInput
  upsert: StoreUpsertWithoutMenuListInput
  connect: StoreWhereUniqueInput
}

input StoreUpdateWithoutMenuListDataInput {
  pwd: String
  category: CategoryUpdateOneRequiredInput
  minimumPrice: Int
  deliveryFee: Int
  orderList: OrderUpdateManyInput
}

input StoreUpsertNestedInput {
  update: StoreUpdateDataInput!
  create: StoreCreateInput!
}

input StoreUpsertWithoutMenuListInput {
  update: StoreUpdateWithoutMenuListDataInput!
  create: StoreCreateWithoutMenuListInput!
}

input StoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pwd: String
  pwd_not: String
  pwd_in: [String!]
  pwd_not_in: [String!]
  pwd_lt: String
  pwd_lte: String
  pwd_gt: String
  pwd_gte: String
  pwd_contains: String
  pwd_not_contains: String
  pwd_starts_with: String
  pwd_not_starts_with: String
  pwd_ends_with: String
  pwd_not_ends_with: String
  category: CategoryWhereInput
  menuList_every: MenuWhereInput
  menuList_some: MenuWhereInput
  menuList_none: MenuWhereInput
  minimumPrice: Int
  minimumPrice_not: Int
  minimumPrice_in: [Int!]
  minimumPrice_not_in: [Int!]
  minimumPrice_lt: Int
  minimumPrice_lte: Int
  minimumPrice_gt: Int
  minimumPrice_gte: Int
  deliveryFee: Int
  deliveryFee_not: Int
  deliveryFee_in: [Int!]
  deliveryFee_not_in: [Int!]
  deliveryFee_lt: Int
  deliveryFee_lte: Int
  deliveryFee_gt: Int
  deliveryFee_gte: Int
  orderList_every: OrderWhereInput
  orderList_some: OrderWhereInput
  orderList_none: OrderWhereInput
  AND: [StoreWhereInput!]
  OR: [StoreWhereInput!]
  NOT: [StoreWhereInput!]
}

input StoreWhereUniqueInput {
  id: ID
}

type Subscription {
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  chatContent(where: ChatContentSubscriptionWhereInput): ChatContentSubscriptionPayload
  chatRoom(where: ChatRoomSubscriptionWhereInput): ChatRoomSubscriptionPayload
  menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  store(where: StoreSubscriptionWhereInput): StoreSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  name: String
  score: Int!
  chatList(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  name: String
  score: Int!
  chatList: ChatRoomCreateManyWithoutBossInput
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutChatListInput {
  create: UserCreateWithoutChatListInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutChatListInput {
  id: ID
  email: String!
  name: String
  score: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  score_ASC
  score_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String
  score: Int!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  name: String
  score: Int
  chatList: ChatRoomUpdateManyWithoutBossInput
}

input UserUpdateInput {
  email: String
  name: String
  score: Int
  chatList: ChatRoomUpdateManyWithoutBossInput
}

input UserUpdateManyDataInput {
  email: String
  name: String
  score: Int
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  score: Int
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutChatListInput {
  create: UserCreateWithoutChatListInput
  update: UserUpdateWithoutChatListDataInput
  upsert: UserUpsertWithoutChatListInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutChatListDataInput {
  email: String
  name: String
  score: Int
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutChatListInput {
  update: UserUpdateWithoutChatListDataInput!
  create: UserCreateWithoutChatListInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  chatList_every: ChatRoomWhereInput
  chatList_some: ChatRoomWhereInput
  chatList_none: ChatRoomWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    