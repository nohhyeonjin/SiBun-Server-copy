module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateChatContent {
  count: Int!
}

type AggregateChatRoom {
  count: Int!
}

type AggregateIndividualOrder {
  count: Int!
}

type AggregateMenu {
  count: Int!
}

type AggregateMenuCategory {
  count: Int!
}

type AggregateRoomOrder {
  count: Int!
}

type AggregateStore {
  count: Int!
}

type AggregateStoreCategory {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserVote {
  count: Int!
}

type AggregateVote {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ChatContent {
  id: ID!
  user: User!
  chatRoom: ChatRoom!
  content: String!
}

type ChatContentConnection {
  pageInfo: PageInfo!
  edges: [ChatContentEdge]!
  aggregate: AggregateChatContent!
}

input ChatContentCreateInput {
  id: ID
  user: UserCreateOneInput!
  chatRoom: ChatRoomCreateOneWithoutChatContentListInput!
  content: String!
}

input ChatContentCreateManyWithoutChatRoomInput {
  create: [ChatContentCreateWithoutChatRoomInput!]
  connect: [ChatContentWhereUniqueInput!]
}

input ChatContentCreateWithoutChatRoomInput {
  id: ID
  user: UserCreateOneInput!
  content: String!
}

type ChatContentEdge {
  node: ChatContent!
  cursor: String!
}

enum ChatContentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
}

type ChatContentPreviousValues {
  id: ID!
  content: String!
}

input ChatContentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [ChatContentScalarWhereInput!]
  OR: [ChatContentScalarWhereInput!]
  NOT: [ChatContentScalarWhereInput!]
}

type ChatContentSubscriptionPayload {
  mutation: MutationType!
  node: ChatContent
  updatedFields: [String!]
  previousValues: ChatContentPreviousValues
}

input ChatContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatContentWhereInput
  AND: [ChatContentSubscriptionWhereInput!]
  OR: [ChatContentSubscriptionWhereInput!]
  NOT: [ChatContentSubscriptionWhereInput!]
}

input ChatContentUpdateInput {
  user: UserUpdateOneRequiredInput
  chatRoom: ChatRoomUpdateOneRequiredWithoutChatContentListInput
  content: String
}

input ChatContentUpdateManyDataInput {
  content: String
}

input ChatContentUpdateManyMutationInput {
  content: String
}

input ChatContentUpdateManyWithoutChatRoomInput {
  create: [ChatContentCreateWithoutChatRoomInput!]
  delete: [ChatContentWhereUniqueInput!]
  connect: [ChatContentWhereUniqueInput!]
  set: [ChatContentWhereUniqueInput!]
  disconnect: [ChatContentWhereUniqueInput!]
  update: [ChatContentUpdateWithWhereUniqueWithoutChatRoomInput!]
  upsert: [ChatContentUpsertWithWhereUniqueWithoutChatRoomInput!]
  deleteMany: [ChatContentScalarWhereInput!]
  updateMany: [ChatContentUpdateManyWithWhereNestedInput!]
}

input ChatContentUpdateManyWithWhereNestedInput {
  where: ChatContentScalarWhereInput!
  data: ChatContentUpdateManyDataInput!
}

input ChatContentUpdateWithoutChatRoomDataInput {
  user: UserUpdateOneRequiredInput
  content: String
}

input ChatContentUpdateWithWhereUniqueWithoutChatRoomInput {
  where: ChatContentWhereUniqueInput!
  data: ChatContentUpdateWithoutChatRoomDataInput!
}

input ChatContentUpsertWithWhereUniqueWithoutChatRoomInput {
  where: ChatContentWhereUniqueInput!
  update: ChatContentUpdateWithoutChatRoomDataInput!
  create: ChatContentCreateWithoutChatRoomInput!
}

input ChatContentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  chatRoom: ChatRoomWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [ChatContentWhereInput!]
  OR: [ChatContentWhereInput!]
  NOT: [ChatContentWhereInput!]
}

input ChatContentWhereUniqueInput {
  id: ID
}

type ChatRoom {
  id: ID!
  boss: User!
  memberList(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  store: Store!
  location: String!
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime!
  roomOrder: RoomOrder
  chatContentList(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatContent!]
  state: Boolean!
}

type ChatRoomConnection {
  pageInfo: PageInfo!
  edges: [ChatRoomEdge]!
  aggregate: AggregateChatRoom!
}

input ChatRoomCreateInput {
  id: ID
  boss: UserCreateOneWithoutBossChatListInput!
  memberList: UserCreateManyWithoutChatListInput
  store: StoreCreateOneWithoutChatRoomListInput!
  location: String!
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime!
  roomOrder: RoomOrderCreateOneWithoutChatRoomInput
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateManyWithoutBossInput {
  create: [ChatRoomCreateWithoutBossInput!]
  connect: [ChatRoomWhereUniqueInput!]
}

input ChatRoomCreateManyWithoutMemberListInput {
  create: [ChatRoomCreateWithoutMemberListInput!]
  connect: [ChatRoomWhereUniqueInput!]
}

input ChatRoomCreateManyWithoutStoreInput {
  create: [ChatRoomCreateWithoutStoreInput!]
  connect: [ChatRoomWhereUniqueInput!]
}

input ChatRoomCreateOneInput {
  create: ChatRoomCreateInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateOneWithoutChatContentListInput {
  create: ChatRoomCreateWithoutChatContentListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateOneWithoutRoomOrderInput {
  create: ChatRoomCreateWithoutRoomOrderInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateWithoutBossInput {
  id: ID
  memberList: UserCreateManyWithoutChatListInput
  store: StoreCreateOneWithoutChatRoomListInput!
  location: String!
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime!
  roomOrder: RoomOrderCreateOneWithoutChatRoomInput
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateWithoutChatContentListInput {
  id: ID
  boss: UserCreateOneWithoutBossChatListInput!
  memberList: UserCreateManyWithoutChatListInput
  store: StoreCreateOneWithoutChatRoomListInput!
  location: String!
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime!
  roomOrder: RoomOrderCreateOneWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateWithoutMemberListInput {
  id: ID
  boss: UserCreateOneWithoutBossChatListInput!
  store: StoreCreateOneWithoutChatRoomListInput!
  location: String!
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime!
  roomOrder: RoomOrderCreateOneWithoutChatRoomInput
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateWithoutRoomOrderInput {
  id: ID
  boss: UserCreateOneWithoutBossChatListInput!
  memberList: UserCreateManyWithoutChatListInput
  store: StoreCreateOneWithoutChatRoomListInput!
  location: String!
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime!
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

input ChatRoomCreateWithoutStoreInput {
  id: ID
  boss: UserCreateOneWithoutBossChatListInput!
  memberList: UserCreateManyWithoutChatListInput
  location: String!
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime!
  roomOrder: RoomOrderCreateOneWithoutChatRoomInput
  chatContentList: ChatContentCreateManyWithoutChatRoomInput
  state: Boolean!
}

type ChatRoomEdge {
  node: ChatRoom!
  cursor: String!
}

enum ChatRoomOrderByInput {
  id_ASC
  id_DESC
  location_ASC
  location_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  orderExpectedTime_ASC
  orderExpectedTime_DESC
  state_ASC
  state_DESC
}

type ChatRoomPreviousValues {
  id: ID!
  location: String!
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime!
  state: Boolean!
}

input ChatRoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  orderExpectedTime: DateTime
  orderExpectedTime_not: DateTime
  orderExpectedTime_in: [DateTime!]
  orderExpectedTime_not_in: [DateTime!]
  orderExpectedTime_lt: DateTime
  orderExpectedTime_lte: DateTime
  orderExpectedTime_gt: DateTime
  orderExpectedTime_gte: DateTime
  state: Boolean
  state_not: Boolean
  AND: [ChatRoomScalarWhereInput!]
  OR: [ChatRoomScalarWhereInput!]
  NOT: [ChatRoomScalarWhereInput!]
}

type ChatRoomSubscriptionPayload {
  mutation: MutationType!
  node: ChatRoom
  updatedFields: [String!]
  previousValues: ChatRoomPreviousValues
}

input ChatRoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatRoomWhereInput
  AND: [ChatRoomSubscriptionWhereInput!]
  OR: [ChatRoomSubscriptionWhereInput!]
  NOT: [ChatRoomSubscriptionWhereInput!]
}

input ChatRoomUpdateDataInput {
  boss: UserUpdateOneRequiredWithoutBossChatListInput
  memberList: UserUpdateManyWithoutChatListInput
  store: StoreUpdateOneRequiredWithoutChatRoomListInput
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  roomOrder: RoomOrderUpdateOneWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateInput {
  boss: UserUpdateOneRequiredWithoutBossChatListInput
  memberList: UserUpdateManyWithoutChatListInput
  store: StoreUpdateOneRequiredWithoutChatRoomListInput
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  roomOrder: RoomOrderUpdateOneWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateManyDataInput {
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  state: Boolean
}

input ChatRoomUpdateManyMutationInput {
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  state: Boolean
}

input ChatRoomUpdateManyWithoutBossInput {
  create: [ChatRoomCreateWithoutBossInput!]
  delete: [ChatRoomWhereUniqueInput!]
  connect: [ChatRoomWhereUniqueInput!]
  set: [ChatRoomWhereUniqueInput!]
  disconnect: [ChatRoomWhereUniqueInput!]
  update: [ChatRoomUpdateWithWhereUniqueWithoutBossInput!]
  upsert: [ChatRoomUpsertWithWhereUniqueWithoutBossInput!]
  deleteMany: [ChatRoomScalarWhereInput!]
  updateMany: [ChatRoomUpdateManyWithWhereNestedInput!]
}

input ChatRoomUpdateManyWithoutMemberListInput {
  create: [ChatRoomCreateWithoutMemberListInput!]
  delete: [ChatRoomWhereUniqueInput!]
  connect: [ChatRoomWhereUniqueInput!]
  set: [ChatRoomWhereUniqueInput!]
  disconnect: [ChatRoomWhereUniqueInput!]
  update: [ChatRoomUpdateWithWhereUniqueWithoutMemberListInput!]
  upsert: [ChatRoomUpsertWithWhereUniqueWithoutMemberListInput!]
  deleteMany: [ChatRoomScalarWhereInput!]
  updateMany: [ChatRoomUpdateManyWithWhereNestedInput!]
}

input ChatRoomUpdateManyWithoutStoreInput {
  create: [ChatRoomCreateWithoutStoreInput!]
  delete: [ChatRoomWhereUniqueInput!]
  connect: [ChatRoomWhereUniqueInput!]
  set: [ChatRoomWhereUniqueInput!]
  disconnect: [ChatRoomWhereUniqueInput!]
  update: [ChatRoomUpdateWithWhereUniqueWithoutStoreInput!]
  upsert: [ChatRoomUpsertWithWhereUniqueWithoutStoreInput!]
  deleteMany: [ChatRoomScalarWhereInput!]
  updateMany: [ChatRoomUpdateManyWithWhereNestedInput!]
}

input ChatRoomUpdateManyWithWhereNestedInput {
  where: ChatRoomScalarWhereInput!
  data: ChatRoomUpdateManyDataInput!
}

input ChatRoomUpdateOneRequiredInput {
  create: ChatRoomCreateInput
  update: ChatRoomUpdateDataInput
  upsert: ChatRoomUpsertNestedInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateOneRequiredWithoutChatContentListInput {
  create: ChatRoomCreateWithoutChatContentListInput
  update: ChatRoomUpdateWithoutChatContentListDataInput
  upsert: ChatRoomUpsertWithoutChatContentListInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateOneRequiredWithoutRoomOrderInput {
  create: ChatRoomCreateWithoutRoomOrderInput
  update: ChatRoomUpdateWithoutRoomOrderDataInput
  upsert: ChatRoomUpsertWithoutRoomOrderInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateWithoutBossDataInput {
  memberList: UserUpdateManyWithoutChatListInput
  store: StoreUpdateOneRequiredWithoutChatRoomListInput
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  roomOrder: RoomOrderUpdateOneWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithoutChatContentListDataInput {
  boss: UserUpdateOneRequiredWithoutBossChatListInput
  memberList: UserUpdateManyWithoutChatListInput
  store: StoreUpdateOneRequiredWithoutChatRoomListInput
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  roomOrder: RoomOrderUpdateOneWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithoutMemberListDataInput {
  boss: UserUpdateOneRequiredWithoutBossChatListInput
  store: StoreUpdateOneRequiredWithoutChatRoomListInput
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  roomOrder: RoomOrderUpdateOneWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithoutRoomOrderDataInput {
  boss: UserUpdateOneRequiredWithoutBossChatListInput
  memberList: UserUpdateManyWithoutChatListInput
  store: StoreUpdateOneRequiredWithoutChatRoomListInput
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithoutStoreDataInput {
  boss: UserUpdateOneRequiredWithoutBossChatListInput
  memberList: UserUpdateManyWithoutChatListInput
  location: String
  latitude: Float
  longitude: Float
  orderExpectedTime: DateTime
  roomOrder: RoomOrderUpdateOneWithoutChatRoomInput
  chatContentList: ChatContentUpdateManyWithoutChatRoomInput
  state: Boolean
}

input ChatRoomUpdateWithWhereUniqueWithoutBossInput {
  where: ChatRoomWhereUniqueInput!
  data: ChatRoomUpdateWithoutBossDataInput!
}

input ChatRoomUpdateWithWhereUniqueWithoutMemberListInput {
  where: ChatRoomWhereUniqueInput!
  data: ChatRoomUpdateWithoutMemberListDataInput!
}

input ChatRoomUpdateWithWhereUniqueWithoutStoreInput {
  where: ChatRoomWhereUniqueInput!
  data: ChatRoomUpdateWithoutStoreDataInput!
}

input ChatRoomUpsertNestedInput {
  update: ChatRoomUpdateDataInput!
  create: ChatRoomCreateInput!
}

input ChatRoomUpsertWithoutChatContentListInput {
  update: ChatRoomUpdateWithoutChatContentListDataInput!
  create: ChatRoomCreateWithoutChatContentListInput!
}

input ChatRoomUpsertWithoutRoomOrderInput {
  update: ChatRoomUpdateWithoutRoomOrderDataInput!
  create: ChatRoomCreateWithoutRoomOrderInput!
}

input ChatRoomUpsertWithWhereUniqueWithoutBossInput {
  where: ChatRoomWhereUniqueInput!
  update: ChatRoomUpdateWithoutBossDataInput!
  create: ChatRoomCreateWithoutBossInput!
}

input ChatRoomUpsertWithWhereUniqueWithoutMemberListInput {
  where: ChatRoomWhereUniqueInput!
  update: ChatRoomUpdateWithoutMemberListDataInput!
  create: ChatRoomCreateWithoutMemberListInput!
}

input ChatRoomUpsertWithWhereUniqueWithoutStoreInput {
  where: ChatRoomWhereUniqueInput!
  update: ChatRoomUpdateWithoutStoreDataInput!
  create: ChatRoomCreateWithoutStoreInput!
}

input ChatRoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  boss: UserWhereInput
  memberList_every: UserWhereInput
  memberList_some: UserWhereInput
  memberList_none: UserWhereInput
  store: StoreWhereInput
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  orderExpectedTime: DateTime
  orderExpectedTime_not: DateTime
  orderExpectedTime_in: [DateTime!]
  orderExpectedTime_not_in: [DateTime!]
  orderExpectedTime_lt: DateTime
  orderExpectedTime_lte: DateTime
  orderExpectedTime_gt: DateTime
  orderExpectedTime_gte: DateTime
  roomOrder: RoomOrderWhereInput
  chatContentList_every: ChatContentWhereInput
  chatContentList_some: ChatContentWhereInput
  chatContentList_none: ChatContentWhereInput
  state: Boolean
  state_not: Boolean
  AND: [ChatRoomWhereInput!]
  OR: [ChatRoomWhereInput!]
  NOT: [ChatRoomWhereInput!]
}

input ChatRoomWhereUniqueInput {
  id: ID
}

scalar DateTime

type IndividualOrder {
  id: ID!
  user: User!
  menuList(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  roomOrder: RoomOrder
}

type IndividualOrderConnection {
  pageInfo: PageInfo!
  edges: [IndividualOrderEdge]!
  aggregate: AggregateIndividualOrder!
}

input IndividualOrderCreateInput {
  id: ID
  user: UserCreateOneInput!
  menuList: MenuCreateManyInput
  roomOrder: RoomOrderCreateOneWithoutIndividualOrderListInput
}

input IndividualOrderCreateManyWithoutRoomOrderInput {
  create: [IndividualOrderCreateWithoutRoomOrderInput!]
  connect: [IndividualOrderWhereUniqueInput!]
}

input IndividualOrderCreateWithoutRoomOrderInput {
  id: ID
  user: UserCreateOneInput!
  menuList: MenuCreateManyInput
}

type IndividualOrderEdge {
  node: IndividualOrder!
  cursor: String!
}

enum IndividualOrderOrderByInput {
  id_ASC
  id_DESC
}

type IndividualOrderPreviousValues {
  id: ID!
}

input IndividualOrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [IndividualOrderScalarWhereInput!]
  OR: [IndividualOrderScalarWhereInput!]
  NOT: [IndividualOrderScalarWhereInput!]
}

type IndividualOrderSubscriptionPayload {
  mutation: MutationType!
  node: IndividualOrder
  updatedFields: [String!]
  previousValues: IndividualOrderPreviousValues
}

input IndividualOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IndividualOrderWhereInput
  AND: [IndividualOrderSubscriptionWhereInput!]
  OR: [IndividualOrderSubscriptionWhereInput!]
  NOT: [IndividualOrderSubscriptionWhereInput!]
}

input IndividualOrderUpdateInput {
  user: UserUpdateOneRequiredInput
  menuList: MenuUpdateManyInput
  roomOrder: RoomOrderUpdateOneWithoutIndividualOrderListInput
}

input IndividualOrderUpdateManyWithoutRoomOrderInput {
  create: [IndividualOrderCreateWithoutRoomOrderInput!]
  delete: [IndividualOrderWhereUniqueInput!]
  connect: [IndividualOrderWhereUniqueInput!]
  set: [IndividualOrderWhereUniqueInput!]
  disconnect: [IndividualOrderWhereUniqueInput!]
  update: [IndividualOrderUpdateWithWhereUniqueWithoutRoomOrderInput!]
  upsert: [IndividualOrderUpsertWithWhereUniqueWithoutRoomOrderInput!]
  deleteMany: [IndividualOrderScalarWhereInput!]
}

input IndividualOrderUpdateWithoutRoomOrderDataInput {
  user: UserUpdateOneRequiredInput
  menuList: MenuUpdateManyInput
}

input IndividualOrderUpdateWithWhereUniqueWithoutRoomOrderInput {
  where: IndividualOrderWhereUniqueInput!
  data: IndividualOrderUpdateWithoutRoomOrderDataInput!
}

input IndividualOrderUpsertWithWhereUniqueWithoutRoomOrderInput {
  where: IndividualOrderWhereUniqueInput!
  update: IndividualOrderUpdateWithoutRoomOrderDataInput!
  create: IndividualOrderCreateWithoutRoomOrderInput!
}

input IndividualOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  menuList_every: MenuWhereInput
  menuList_some: MenuWhereInput
  menuList_none: MenuWhereInput
  roomOrder: RoomOrderWhereInput
  AND: [IndividualOrderWhereInput!]
  OR: [IndividualOrderWhereInput!]
  NOT: [IndividualOrderWhereInput!]
}

input IndividualOrderWhereUniqueInput {
  id: ID
}

scalar Long

type Menu {
  id: ID!
  name: String!
  price: Int!
  menuCategory: MenuCategory!
}

type MenuCategory {
  id: ID!
  name: String!
  store: Store!
  menuList(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
}

type MenuCategoryConnection {
  pageInfo: PageInfo!
  edges: [MenuCategoryEdge]!
  aggregate: AggregateMenuCategory!
}

input MenuCategoryCreateInput {
  id: ID
  name: String!
  store: StoreCreateOneWithoutMenuCategoryListInput!
  menuList: MenuCreateManyWithoutMenuCategoryInput
}

input MenuCategoryCreateManyWithoutStoreInput {
  create: [MenuCategoryCreateWithoutStoreInput!]
  connect: [MenuCategoryWhereUniqueInput!]
}

input MenuCategoryCreateOneWithoutMenuListInput {
  create: MenuCategoryCreateWithoutMenuListInput
  connect: MenuCategoryWhereUniqueInput
}

input MenuCategoryCreateWithoutMenuListInput {
  id: ID
  name: String!
  store: StoreCreateOneWithoutMenuCategoryListInput!
}

input MenuCategoryCreateWithoutStoreInput {
  id: ID
  name: String!
  menuList: MenuCreateManyWithoutMenuCategoryInput
}

type MenuCategoryEdge {
  node: MenuCategory!
  cursor: String!
}

enum MenuCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type MenuCategoryPreviousValues {
  id: ID!
  name: String!
}

input MenuCategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [MenuCategoryScalarWhereInput!]
  OR: [MenuCategoryScalarWhereInput!]
  NOT: [MenuCategoryScalarWhereInput!]
}

type MenuCategorySubscriptionPayload {
  mutation: MutationType!
  node: MenuCategory
  updatedFields: [String!]
  previousValues: MenuCategoryPreviousValues
}

input MenuCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuCategoryWhereInput
  AND: [MenuCategorySubscriptionWhereInput!]
  OR: [MenuCategorySubscriptionWhereInput!]
  NOT: [MenuCategorySubscriptionWhereInput!]
}

input MenuCategoryUpdateInput {
  name: String
  store: StoreUpdateOneRequiredWithoutMenuCategoryListInput
  menuList: MenuUpdateManyWithoutMenuCategoryInput
}

input MenuCategoryUpdateManyDataInput {
  name: String
}

input MenuCategoryUpdateManyMutationInput {
  name: String
}

input MenuCategoryUpdateManyWithoutStoreInput {
  create: [MenuCategoryCreateWithoutStoreInput!]
  delete: [MenuCategoryWhereUniqueInput!]
  connect: [MenuCategoryWhereUniqueInput!]
  set: [MenuCategoryWhereUniqueInput!]
  disconnect: [MenuCategoryWhereUniqueInput!]
  update: [MenuCategoryUpdateWithWhereUniqueWithoutStoreInput!]
  upsert: [MenuCategoryUpsertWithWhereUniqueWithoutStoreInput!]
  deleteMany: [MenuCategoryScalarWhereInput!]
  updateMany: [MenuCategoryUpdateManyWithWhereNestedInput!]
}

input MenuCategoryUpdateManyWithWhereNestedInput {
  where: MenuCategoryScalarWhereInput!
  data: MenuCategoryUpdateManyDataInput!
}

input MenuCategoryUpdateOneRequiredWithoutMenuListInput {
  create: MenuCategoryCreateWithoutMenuListInput
  update: MenuCategoryUpdateWithoutMenuListDataInput
  upsert: MenuCategoryUpsertWithoutMenuListInput
  connect: MenuCategoryWhereUniqueInput
}

input MenuCategoryUpdateWithoutMenuListDataInput {
  name: String
  store: StoreUpdateOneRequiredWithoutMenuCategoryListInput
}

input MenuCategoryUpdateWithoutStoreDataInput {
  name: String
  menuList: MenuUpdateManyWithoutMenuCategoryInput
}

input MenuCategoryUpdateWithWhereUniqueWithoutStoreInput {
  where: MenuCategoryWhereUniqueInput!
  data: MenuCategoryUpdateWithoutStoreDataInput!
}

input MenuCategoryUpsertWithoutMenuListInput {
  update: MenuCategoryUpdateWithoutMenuListDataInput!
  create: MenuCategoryCreateWithoutMenuListInput!
}

input MenuCategoryUpsertWithWhereUniqueWithoutStoreInput {
  where: MenuCategoryWhereUniqueInput!
  update: MenuCategoryUpdateWithoutStoreDataInput!
  create: MenuCategoryCreateWithoutStoreInput!
}

input MenuCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  store: StoreWhereInput
  menuList_every: MenuWhereInput
  menuList_some: MenuWhereInput
  menuList_none: MenuWhereInput
  AND: [MenuCategoryWhereInput!]
  OR: [MenuCategoryWhereInput!]
  NOT: [MenuCategoryWhereInput!]
}

input MenuCategoryWhereUniqueInput {
  id: ID
}

type MenuConnection {
  pageInfo: PageInfo!
  edges: [MenuEdge]!
  aggregate: AggregateMenu!
}

input MenuCreateInput {
  id: ID
  name: String!
  price: Int!
  menuCategory: MenuCategoryCreateOneWithoutMenuListInput!
}

input MenuCreateManyInput {
  create: [MenuCreateInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateManyWithoutMenuCategoryInput {
  create: [MenuCreateWithoutMenuCategoryInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateWithoutMenuCategoryInput {
  id: ID
  name: String!
  price: Int!
}

type MenuEdge {
  node: Menu!
  cursor: String!
}

enum MenuOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
}

type MenuPreviousValues {
  id: ID!
  name: String!
  price: Int!
}

input MenuScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  AND: [MenuScalarWhereInput!]
  OR: [MenuScalarWhereInput!]
  NOT: [MenuScalarWhereInput!]
}

type MenuSubscriptionPayload {
  mutation: MutationType!
  node: Menu
  updatedFields: [String!]
  previousValues: MenuPreviousValues
}

input MenuSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuWhereInput
  AND: [MenuSubscriptionWhereInput!]
  OR: [MenuSubscriptionWhereInput!]
  NOT: [MenuSubscriptionWhereInput!]
}

input MenuUpdateDataInput {
  name: String
  price: Int
  menuCategory: MenuCategoryUpdateOneRequiredWithoutMenuListInput
}

input MenuUpdateInput {
  name: String
  price: Int
  menuCategory: MenuCategoryUpdateOneRequiredWithoutMenuListInput
}

input MenuUpdateManyDataInput {
  name: String
  price: Int
}

input MenuUpdateManyInput {
  create: [MenuCreateInput!]
  update: [MenuUpdateWithWhereUniqueNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueNestedInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyMutationInput {
  name: String
  price: Int
}

input MenuUpdateManyWithoutMenuCategoryInput {
  create: [MenuCreateWithoutMenuCategoryInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutMenuCategoryInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutMenuCategoryInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyWithWhereNestedInput {
  where: MenuScalarWhereInput!
  data: MenuUpdateManyDataInput!
}

input MenuUpdateWithoutMenuCategoryDataInput {
  name: String
  price: Int
}

input MenuUpdateWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateDataInput!
}

input MenuUpdateWithWhereUniqueWithoutMenuCategoryInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateWithoutMenuCategoryDataInput!
}

input MenuUpsertWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateDataInput!
  create: MenuCreateInput!
}

input MenuUpsertWithWhereUniqueWithoutMenuCategoryInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateWithoutMenuCategoryDataInput!
  create: MenuCreateWithoutMenuCategoryInput!
}

input MenuWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  menuCategory: MenuCategoryWhereInput
  AND: [MenuWhereInput!]
  OR: [MenuWhereInput!]
  NOT: [MenuWhereInput!]
}

input MenuWhereUniqueInput {
  id: ID
}

type Mutation {
  createChatContent(data: ChatContentCreateInput!): ChatContent!
  updateChatContent(data: ChatContentUpdateInput!, where: ChatContentWhereUniqueInput!): ChatContent
  updateManyChatContents(data: ChatContentUpdateManyMutationInput!, where: ChatContentWhereInput): BatchPayload!
  upsertChatContent(where: ChatContentWhereUniqueInput!, create: ChatContentCreateInput!, update: ChatContentUpdateInput!): ChatContent!
  deleteChatContent(where: ChatContentWhereUniqueInput!): ChatContent
  deleteManyChatContents(where: ChatContentWhereInput): BatchPayload!
  createChatRoom(data: ChatRoomCreateInput!): ChatRoom!
  updateChatRoom(data: ChatRoomUpdateInput!, where: ChatRoomWhereUniqueInput!): ChatRoom
  updateManyChatRooms(data: ChatRoomUpdateManyMutationInput!, where: ChatRoomWhereInput): BatchPayload!
  upsertChatRoom(where: ChatRoomWhereUniqueInput!, create: ChatRoomCreateInput!, update: ChatRoomUpdateInput!): ChatRoom!
  deleteChatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  deleteManyChatRooms(where: ChatRoomWhereInput): BatchPayload!
  createIndividualOrder(data: IndividualOrderCreateInput!): IndividualOrder!
  updateIndividualOrder(data: IndividualOrderUpdateInput!, where: IndividualOrderWhereUniqueInput!): IndividualOrder
  upsertIndividualOrder(where: IndividualOrderWhereUniqueInput!, create: IndividualOrderCreateInput!, update: IndividualOrderUpdateInput!): IndividualOrder!
  deleteIndividualOrder(where: IndividualOrderWhereUniqueInput!): IndividualOrder
  deleteManyIndividualOrders(where: IndividualOrderWhereInput): BatchPayload!
  createMenu(data: MenuCreateInput!): Menu!
  updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateManyMenus(data: MenuUpdateManyMutationInput!, where: MenuWhereInput): BatchPayload!
  upsertMenu(where: MenuWhereUniqueInput!, create: MenuCreateInput!, update: MenuUpdateInput!): Menu!
  deleteMenu(where: MenuWhereUniqueInput!): Menu
  deleteManyMenus(where: MenuWhereInput): BatchPayload!
  createMenuCategory(data: MenuCategoryCreateInput!): MenuCategory!
  updateMenuCategory(data: MenuCategoryUpdateInput!, where: MenuCategoryWhereUniqueInput!): MenuCategory
  updateManyMenuCategories(data: MenuCategoryUpdateManyMutationInput!, where: MenuCategoryWhereInput): BatchPayload!
  upsertMenuCategory(where: MenuCategoryWhereUniqueInput!, create: MenuCategoryCreateInput!, update: MenuCategoryUpdateInput!): MenuCategory!
  deleteMenuCategory(where: MenuCategoryWhereUniqueInput!): MenuCategory
  deleteManyMenuCategories(where: MenuCategoryWhereInput): BatchPayload!
  createRoomOrder(data: RoomOrderCreateInput!): RoomOrder!
  updateRoomOrder(data: RoomOrderUpdateInput!, where: RoomOrderWhereUniqueInput!): RoomOrder
  updateManyRoomOrders(data: RoomOrderUpdateManyMutationInput!, where: RoomOrderWhereInput): BatchPayload!
  upsertRoomOrder(where: RoomOrderWhereUniqueInput!, create: RoomOrderCreateInput!, update: RoomOrderUpdateInput!): RoomOrder!
  deleteRoomOrder(where: RoomOrderWhereUniqueInput!): RoomOrder
  deleteManyRoomOrders(where: RoomOrderWhereInput): BatchPayload!
  createStore(data: StoreCreateInput!): Store!
  updateStore(data: StoreUpdateInput!, where: StoreWhereUniqueInput!): Store
  updateManyStores(data: StoreUpdateManyMutationInput!, where: StoreWhereInput): BatchPayload!
  upsertStore(where: StoreWhereUniqueInput!, create: StoreCreateInput!, update: StoreUpdateInput!): Store!
  deleteStore(where: StoreWhereUniqueInput!): Store
  deleteManyStores(where: StoreWhereInput): BatchPayload!
  createStoreCategory(data: StoreCategoryCreateInput!): StoreCategory!
  updateStoreCategory(data: StoreCategoryUpdateInput!, where: StoreCategoryWhereUniqueInput!): StoreCategory
  updateManyStoreCategories(data: StoreCategoryUpdateManyMutationInput!, where: StoreCategoryWhereInput): BatchPayload!
  upsertStoreCategory(where: StoreCategoryWhereUniqueInput!, create: StoreCategoryCreateInput!, update: StoreCategoryUpdateInput!): StoreCategory!
  deleteStoreCategory(where: StoreCategoryWhereUniqueInput!): StoreCategory
  deleteManyStoreCategories(where: StoreCategoryWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserVote(data: UserVoteCreateInput!): UserVote!
  updateUserVote(data: UserVoteUpdateInput!, where: UserVoteWhereUniqueInput!): UserVote
  updateManyUserVotes(data: UserVoteUpdateManyMutationInput!, where: UserVoteWhereInput): BatchPayload!
  upsertUserVote(where: UserVoteWhereUniqueInput!, create: UserVoteCreateInput!, update: UserVoteUpdateInput!): UserVote!
  deleteUserVote(where: UserVoteWhereUniqueInput!): UserVote
  deleteManyUserVotes(where: UserVoteWhereInput): BatchPayload!
  createVote(data: VoteCreateInput!): Vote!
  updateVote(data: VoteUpdateInput!, where: VoteWhereUniqueInput!): Vote
  upsertVote(where: VoteWhereUniqueInput!, create: VoteCreateInput!, update: VoteUpdateInput!): Vote!
  deleteVote(where: VoteWhereUniqueInput!): Vote
  deleteManyVotes(where: VoteWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  chatContent(where: ChatContentWhereUniqueInput!): ChatContent
  chatContents(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatContent]!
  chatContentsConnection(where: ChatContentWhereInput, orderBy: ChatContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatContentConnection!
  chatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  chatRooms(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom]!
  chatRoomsConnection(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatRoomConnection!
  individualOrder(where: IndividualOrderWhereUniqueInput!): IndividualOrder
  individualOrders(where: IndividualOrderWhereInput, orderBy: IndividualOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IndividualOrder]!
  individualOrdersConnection(where: IndividualOrderWhereInput, orderBy: IndividualOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IndividualOrderConnection!
  menu(where: MenuWhereUniqueInput!): Menu
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu]!
  menusConnection(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuConnection!
  menuCategory(where: MenuCategoryWhereUniqueInput!): MenuCategory
  menuCategories(where: MenuCategoryWhereInput, orderBy: MenuCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuCategory]!
  menuCategoriesConnection(where: MenuCategoryWhereInput, orderBy: MenuCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuCategoryConnection!
  roomOrder(where: RoomOrderWhereUniqueInput!): RoomOrder
  roomOrders(where: RoomOrderWhereInput, orderBy: RoomOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RoomOrder]!
  roomOrdersConnection(where: RoomOrderWhereInput, orderBy: RoomOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomOrderConnection!
  store(where: StoreWhereUniqueInput!): Store
  stores(where: StoreWhereInput, orderBy: StoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Store]!
  storesConnection(where: StoreWhereInput, orderBy: StoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StoreConnection!
  storeCategory(where: StoreCategoryWhereUniqueInput!): StoreCategory
  storeCategories(where: StoreCategoryWhereInput, orderBy: StoreCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StoreCategory]!
  storeCategoriesConnection(where: StoreCategoryWhereInput, orderBy: StoreCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StoreCategoryConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userVote(where: UserVoteWhereUniqueInput!): UserVote
  userVotes(where: UserVoteWhereInput, orderBy: UserVoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserVote]!
  userVotesConnection(where: UserVoteWhereInput, orderBy: UserVoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserVoteConnection!
  vote(where: VoteWhereUniqueInput!): Vote
  votes(where: VoteWhereInput, orderBy: VoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vote]!
  votesConnection(where: VoteWhereInput, orderBy: VoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VoteConnection!
  node(id: ID!): Node
}

type RoomOrder {
  id: ID!
  chatRoom: ChatRoom!
  individualOrderList(where: IndividualOrderWhereInput, orderBy: IndividualOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IndividualOrder!]
  phoneNumber: String
  state: Boolean!
}

type RoomOrderConnection {
  pageInfo: PageInfo!
  edges: [RoomOrderEdge]!
  aggregate: AggregateRoomOrder!
}

input RoomOrderCreateInput {
  id: ID
  chatRoom: ChatRoomCreateOneWithoutRoomOrderInput!
  individualOrderList: IndividualOrderCreateManyWithoutRoomOrderInput
  phoneNumber: String
  state: Boolean!
}

input RoomOrderCreateOneWithoutChatRoomInput {
  create: RoomOrderCreateWithoutChatRoomInput
  connect: RoomOrderWhereUniqueInput
}

input RoomOrderCreateOneWithoutIndividualOrderListInput {
  create: RoomOrderCreateWithoutIndividualOrderListInput
  connect: RoomOrderWhereUniqueInput
}

input RoomOrderCreateWithoutChatRoomInput {
  id: ID
  individualOrderList: IndividualOrderCreateManyWithoutRoomOrderInput
  phoneNumber: String
  state: Boolean!
}

input RoomOrderCreateWithoutIndividualOrderListInput {
  id: ID
  chatRoom: ChatRoomCreateOneWithoutRoomOrderInput!
  phoneNumber: String
  state: Boolean!
}

type RoomOrderEdge {
  node: RoomOrder!
  cursor: String!
}

enum RoomOrderOrderByInput {
  id_ASC
  id_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  state_ASC
  state_DESC
}

type RoomOrderPreviousValues {
  id: ID!
  phoneNumber: String
  state: Boolean!
}

type RoomOrderSubscriptionPayload {
  mutation: MutationType!
  node: RoomOrder
  updatedFields: [String!]
  previousValues: RoomOrderPreviousValues
}

input RoomOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomOrderWhereInput
  AND: [RoomOrderSubscriptionWhereInput!]
  OR: [RoomOrderSubscriptionWhereInput!]
  NOT: [RoomOrderSubscriptionWhereInput!]
}

input RoomOrderUpdateInput {
  chatRoom: ChatRoomUpdateOneRequiredWithoutRoomOrderInput
  individualOrderList: IndividualOrderUpdateManyWithoutRoomOrderInput
  phoneNumber: String
  state: Boolean
}

input RoomOrderUpdateManyMutationInput {
  phoneNumber: String
  state: Boolean
}

input RoomOrderUpdateOneWithoutChatRoomInput {
  create: RoomOrderCreateWithoutChatRoomInput
  update: RoomOrderUpdateWithoutChatRoomDataInput
  upsert: RoomOrderUpsertWithoutChatRoomInput
  delete: Boolean
  disconnect: Boolean
  connect: RoomOrderWhereUniqueInput
}

input RoomOrderUpdateOneWithoutIndividualOrderListInput {
  create: RoomOrderCreateWithoutIndividualOrderListInput
  update: RoomOrderUpdateWithoutIndividualOrderListDataInput
  upsert: RoomOrderUpsertWithoutIndividualOrderListInput
  delete: Boolean
  disconnect: Boolean
  connect: RoomOrderWhereUniqueInput
}

input RoomOrderUpdateWithoutChatRoomDataInput {
  individualOrderList: IndividualOrderUpdateManyWithoutRoomOrderInput
  phoneNumber: String
  state: Boolean
}

input RoomOrderUpdateWithoutIndividualOrderListDataInput {
  chatRoom: ChatRoomUpdateOneRequiredWithoutRoomOrderInput
  phoneNumber: String
  state: Boolean
}

input RoomOrderUpsertWithoutChatRoomInput {
  update: RoomOrderUpdateWithoutChatRoomDataInput!
  create: RoomOrderCreateWithoutChatRoomInput!
}

input RoomOrderUpsertWithoutIndividualOrderListInput {
  update: RoomOrderUpdateWithoutIndividualOrderListDataInput!
  create: RoomOrderCreateWithoutIndividualOrderListInput!
}

input RoomOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  chatRoom: ChatRoomWhereInput
  individualOrderList_every: IndividualOrderWhereInput
  individualOrderList_some: IndividualOrderWhereInput
  individualOrderList_none: IndividualOrderWhereInput
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  state: Boolean
  state_not: Boolean
  AND: [RoomOrderWhereInput!]
  OR: [RoomOrderWhereInput!]
  NOT: [RoomOrderWhereInput!]
}

input RoomOrderWhereUniqueInput {
  id: ID
}

type Store {
  id: ID!
  storeId: String!
  pwd: String!
  name: String!
  storeCategory: StoreCategory!
  menuCategoryList(where: MenuCategoryWhereInput, orderBy: MenuCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuCategory!]
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
  chatRoomList(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom!]
}

type StoreCategory {
  id: ID!
  name: String!
  storeList(where: StoreWhereInput, orderBy: StoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Store!]
}

type StoreCategoryConnection {
  pageInfo: PageInfo!
  edges: [StoreCategoryEdge]!
  aggregate: AggregateStoreCategory!
}

input StoreCategoryCreateInput {
  id: ID
  name: String!
  storeList: StoreCreateManyWithoutStoreCategoryInput
}

input StoreCategoryCreateOneWithoutStoreListInput {
  create: StoreCategoryCreateWithoutStoreListInput
  connect: StoreCategoryWhereUniqueInput
}

input StoreCategoryCreateWithoutStoreListInput {
  id: ID
  name: String!
}

type StoreCategoryEdge {
  node: StoreCategory!
  cursor: String!
}

enum StoreCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type StoreCategoryPreviousValues {
  id: ID!
  name: String!
}

type StoreCategorySubscriptionPayload {
  mutation: MutationType!
  node: StoreCategory
  updatedFields: [String!]
  previousValues: StoreCategoryPreviousValues
}

input StoreCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StoreCategoryWhereInput
  AND: [StoreCategorySubscriptionWhereInput!]
  OR: [StoreCategorySubscriptionWhereInput!]
  NOT: [StoreCategorySubscriptionWhereInput!]
}

input StoreCategoryUpdateInput {
  name: String
  storeList: StoreUpdateManyWithoutStoreCategoryInput
}

input StoreCategoryUpdateManyMutationInput {
  name: String
}

input StoreCategoryUpdateOneRequiredWithoutStoreListInput {
  create: StoreCategoryCreateWithoutStoreListInput
  update: StoreCategoryUpdateWithoutStoreListDataInput
  upsert: StoreCategoryUpsertWithoutStoreListInput
  connect: StoreCategoryWhereUniqueInput
}

input StoreCategoryUpdateWithoutStoreListDataInput {
  name: String
}

input StoreCategoryUpsertWithoutStoreListInput {
  update: StoreCategoryUpdateWithoutStoreListDataInput!
  create: StoreCategoryCreateWithoutStoreListInput!
}

input StoreCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  storeList_every: StoreWhereInput
  storeList_some: StoreWhereInput
  storeList_none: StoreWhereInput
  AND: [StoreCategoryWhereInput!]
  OR: [StoreCategoryWhereInput!]
  NOT: [StoreCategoryWhereInput!]
}

input StoreCategoryWhereUniqueInput {
  id: ID
}

type StoreConnection {
  pageInfo: PageInfo!
  edges: [StoreEdge]!
  aggregate: AggregateStore!
}

input StoreCreateInput {
  id: ID
  storeId: String!
  pwd: String!
  name: String!
  storeCategory: StoreCategoryCreateOneWithoutStoreListInput!
  menuCategoryList: MenuCategoryCreateManyWithoutStoreInput
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
  chatRoomList: ChatRoomCreateManyWithoutStoreInput
}

input StoreCreateManyWithoutStoreCategoryInput {
  create: [StoreCreateWithoutStoreCategoryInput!]
  connect: [StoreWhereUniqueInput!]
}

input StoreCreateOneWithoutChatRoomListInput {
  create: StoreCreateWithoutChatRoomListInput
  connect: StoreWhereUniqueInput
}

input StoreCreateOneWithoutMenuCategoryListInput {
  create: StoreCreateWithoutMenuCategoryListInput
  connect: StoreWhereUniqueInput
}

input StoreCreateWithoutChatRoomListInput {
  id: ID
  storeId: String!
  pwd: String!
  name: String!
  storeCategory: StoreCategoryCreateOneWithoutStoreListInput!
  menuCategoryList: MenuCategoryCreateManyWithoutStoreInput
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
}

input StoreCreateWithoutMenuCategoryListInput {
  id: ID
  storeId: String!
  pwd: String!
  name: String!
  storeCategory: StoreCategoryCreateOneWithoutStoreListInput!
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
  chatRoomList: ChatRoomCreateManyWithoutStoreInput
}

input StoreCreateWithoutStoreCategoryInput {
  id: ID
  storeId: String!
  pwd: String!
  name: String!
  menuCategoryList: MenuCategoryCreateManyWithoutStoreInput
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
  chatRoomList: ChatRoomCreateManyWithoutStoreInput
}

type StoreEdge {
  node: Store!
  cursor: String!
}

enum StoreOrderByInput {
  id_ASC
  id_DESC
  storeId_ASC
  storeId_DESC
  pwd_ASC
  pwd_DESC
  name_ASC
  name_DESC
  minimumPrice_ASC
  minimumPrice_DESC
  deliveryFee_ASC
  deliveryFee_DESC
  image_ASC
  image_DESC
}

type StorePreviousValues {
  id: ID!
  storeId: String!
  pwd: String!
  name: String!
  minimumPrice: Int!
  deliveryFee: Int!
  image: String
}

input StoreScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  storeId: String
  storeId_not: String
  storeId_in: [String!]
  storeId_not_in: [String!]
  storeId_lt: String
  storeId_lte: String
  storeId_gt: String
  storeId_gte: String
  storeId_contains: String
  storeId_not_contains: String
  storeId_starts_with: String
  storeId_not_starts_with: String
  storeId_ends_with: String
  storeId_not_ends_with: String
  pwd: String
  pwd_not: String
  pwd_in: [String!]
  pwd_not_in: [String!]
  pwd_lt: String
  pwd_lte: String
  pwd_gt: String
  pwd_gte: String
  pwd_contains: String
  pwd_not_contains: String
  pwd_starts_with: String
  pwd_not_starts_with: String
  pwd_ends_with: String
  pwd_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  minimumPrice: Int
  minimumPrice_not: Int
  minimumPrice_in: [Int!]
  minimumPrice_not_in: [Int!]
  minimumPrice_lt: Int
  minimumPrice_lte: Int
  minimumPrice_gt: Int
  minimumPrice_gte: Int
  deliveryFee: Int
  deliveryFee_not: Int
  deliveryFee_in: [Int!]
  deliveryFee_not_in: [Int!]
  deliveryFee_lt: Int
  deliveryFee_lte: Int
  deliveryFee_gt: Int
  deliveryFee_gte: Int
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  AND: [StoreScalarWhereInput!]
  OR: [StoreScalarWhereInput!]
  NOT: [StoreScalarWhereInput!]
}

type StoreSubscriptionPayload {
  mutation: MutationType!
  node: Store
  updatedFields: [String!]
  previousValues: StorePreviousValues
}

input StoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StoreWhereInput
  AND: [StoreSubscriptionWhereInput!]
  OR: [StoreSubscriptionWhereInput!]
  NOT: [StoreSubscriptionWhereInput!]
}

input StoreUpdateInput {
  storeId: String
  pwd: String
  name: String
  storeCategory: StoreCategoryUpdateOneRequiredWithoutStoreListInput
  menuCategoryList: MenuCategoryUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  image: String
  chatRoomList: ChatRoomUpdateManyWithoutStoreInput
}

input StoreUpdateManyDataInput {
  storeId: String
  pwd: String
  name: String
  minimumPrice: Int
  deliveryFee: Int
  image: String
}

input StoreUpdateManyMutationInput {
  storeId: String
  pwd: String
  name: String
  minimumPrice: Int
  deliveryFee: Int
  image: String
}

input StoreUpdateManyWithoutStoreCategoryInput {
  create: [StoreCreateWithoutStoreCategoryInput!]
  delete: [StoreWhereUniqueInput!]
  connect: [StoreWhereUniqueInput!]
  set: [StoreWhereUniqueInput!]
  disconnect: [StoreWhereUniqueInput!]
  update: [StoreUpdateWithWhereUniqueWithoutStoreCategoryInput!]
  upsert: [StoreUpsertWithWhereUniqueWithoutStoreCategoryInput!]
  deleteMany: [StoreScalarWhereInput!]
  updateMany: [StoreUpdateManyWithWhereNestedInput!]
}

input StoreUpdateManyWithWhereNestedInput {
  where: StoreScalarWhereInput!
  data: StoreUpdateManyDataInput!
}

input StoreUpdateOneRequiredWithoutChatRoomListInput {
  create: StoreCreateWithoutChatRoomListInput
  update: StoreUpdateWithoutChatRoomListDataInput
  upsert: StoreUpsertWithoutChatRoomListInput
  connect: StoreWhereUniqueInput
}

input StoreUpdateOneRequiredWithoutMenuCategoryListInput {
  create: StoreCreateWithoutMenuCategoryListInput
  update: StoreUpdateWithoutMenuCategoryListDataInput
  upsert: StoreUpsertWithoutMenuCategoryListInput
  connect: StoreWhereUniqueInput
}

input StoreUpdateWithoutChatRoomListDataInput {
  storeId: String
  pwd: String
  name: String
  storeCategory: StoreCategoryUpdateOneRequiredWithoutStoreListInput
  menuCategoryList: MenuCategoryUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  image: String
}

input StoreUpdateWithoutMenuCategoryListDataInput {
  storeId: String
  pwd: String
  name: String
  storeCategory: StoreCategoryUpdateOneRequiredWithoutStoreListInput
  minimumPrice: Int
  deliveryFee: Int
  image: String
  chatRoomList: ChatRoomUpdateManyWithoutStoreInput
}

input StoreUpdateWithoutStoreCategoryDataInput {
  storeId: String
  pwd: String
  name: String
  menuCategoryList: MenuCategoryUpdateManyWithoutStoreInput
  minimumPrice: Int
  deliveryFee: Int
  image: String
  chatRoomList: ChatRoomUpdateManyWithoutStoreInput
}

input StoreUpdateWithWhereUniqueWithoutStoreCategoryInput {
  where: StoreWhereUniqueInput!
  data: StoreUpdateWithoutStoreCategoryDataInput!
}

input StoreUpsertWithoutChatRoomListInput {
  update: StoreUpdateWithoutChatRoomListDataInput!
  create: StoreCreateWithoutChatRoomListInput!
}

input StoreUpsertWithoutMenuCategoryListInput {
  update: StoreUpdateWithoutMenuCategoryListDataInput!
  create: StoreCreateWithoutMenuCategoryListInput!
}

input StoreUpsertWithWhereUniqueWithoutStoreCategoryInput {
  where: StoreWhereUniqueInput!
  update: StoreUpdateWithoutStoreCategoryDataInput!
  create: StoreCreateWithoutStoreCategoryInput!
}

input StoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  storeId: String
  storeId_not: String
  storeId_in: [String!]
  storeId_not_in: [String!]
  storeId_lt: String
  storeId_lte: String
  storeId_gt: String
  storeId_gte: String
  storeId_contains: String
  storeId_not_contains: String
  storeId_starts_with: String
  storeId_not_starts_with: String
  storeId_ends_with: String
  storeId_not_ends_with: String
  pwd: String
  pwd_not: String
  pwd_in: [String!]
  pwd_not_in: [String!]
  pwd_lt: String
  pwd_lte: String
  pwd_gt: String
  pwd_gte: String
  pwd_contains: String
  pwd_not_contains: String
  pwd_starts_with: String
  pwd_not_starts_with: String
  pwd_ends_with: String
  pwd_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  storeCategory: StoreCategoryWhereInput
  menuCategoryList_every: MenuCategoryWhereInput
  menuCategoryList_some: MenuCategoryWhereInput
  menuCategoryList_none: MenuCategoryWhereInput
  minimumPrice: Int
  minimumPrice_not: Int
  minimumPrice_in: [Int!]
  minimumPrice_not_in: [Int!]
  minimumPrice_lt: Int
  minimumPrice_lte: Int
  minimumPrice_gt: Int
  minimumPrice_gte: Int
  deliveryFee: Int
  deliveryFee_not: Int
  deliveryFee_in: [Int!]
  deliveryFee_not_in: [Int!]
  deliveryFee_lt: Int
  deliveryFee_lte: Int
  deliveryFee_gt: Int
  deliveryFee_gte: Int
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  chatRoomList_every: ChatRoomWhereInput
  chatRoomList_some: ChatRoomWhereInput
  chatRoomList_none: ChatRoomWhereInput
  AND: [StoreWhereInput!]
  OR: [StoreWhereInput!]
  NOT: [StoreWhereInput!]
}

input StoreWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  chatContent(where: ChatContentSubscriptionWhereInput): ChatContentSubscriptionPayload
  chatRoom(where: ChatRoomSubscriptionWhereInput): ChatRoomSubscriptionPayload
  individualOrder(where: IndividualOrderSubscriptionWhereInput): IndividualOrderSubscriptionPayload
  menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
  menuCategory(where: MenuCategorySubscriptionWhereInput): MenuCategorySubscriptionPayload
  roomOrder(where: RoomOrderSubscriptionWhereInput): RoomOrderSubscriptionPayload
  store(where: StoreSubscriptionWhereInput): StoreSubscriptionPayload
  storeCategory(where: StoreCategorySubscriptionWhereInput): StoreCategorySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userVote(where: UserVoteSubscriptionWhereInput): UserVoteSubscriptionPayload
  vote(where: VoteSubscriptionWhereInput): VoteSubscriptionPayload
}

type User {
  id: ID!
  number: Int!
  score: Int!
  bossChatList(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom!]
  chatList(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  number: Int!
  score: Int
  bossChatList: ChatRoomCreateManyWithoutBossInput
  chatList: ChatRoomCreateManyWithoutMemberListInput
}

input UserCreateManyWithoutChatListInput {
  create: [UserCreateWithoutChatListInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutBossChatListInput {
  create: UserCreateWithoutBossChatListInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBossChatListInput {
  id: ID
  number: Int!
  score: Int
  chatList: ChatRoomCreateManyWithoutMemberListInput
}

input UserCreateWithoutChatListInput {
  id: ID
  number: Int!
  score: Int
  bossChatList: ChatRoomCreateManyWithoutBossInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  number_ASC
  number_DESC
  score_ASC
  score_DESC
}

type UserPreviousValues {
  id: ID!
  number: Int!
  score: Int!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  number: Int
  score: Int
  bossChatList: ChatRoomUpdateManyWithoutBossInput
  chatList: ChatRoomUpdateManyWithoutMemberListInput
}

input UserUpdateInput {
  number: Int
  score: Int
  bossChatList: ChatRoomUpdateManyWithoutBossInput
  chatList: ChatRoomUpdateManyWithoutMemberListInput
}

input UserUpdateManyDataInput {
  number: Int
  score: Int
}

input UserUpdateManyMutationInput {
  number: Int
  score: Int
}

input UserUpdateManyWithoutChatListInput {
  create: [UserCreateWithoutChatListInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutChatListInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutChatListInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutBossChatListInput {
  create: UserCreateWithoutBossChatListInput
  update: UserUpdateWithoutBossChatListDataInput
  upsert: UserUpsertWithoutBossChatListInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutBossChatListDataInput {
  number: Int
  score: Int
  chatList: ChatRoomUpdateManyWithoutMemberListInput
}

input UserUpdateWithoutChatListDataInput {
  number: Int
  score: Int
  bossChatList: ChatRoomUpdateManyWithoutBossInput
}

input UserUpdateWithWhereUniqueWithoutChatListInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutChatListDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutBossChatListInput {
  update: UserUpdateWithoutBossChatListDataInput!
  create: UserCreateWithoutBossChatListInput!
}

input UserUpsertWithWhereUniqueWithoutChatListInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutChatListDataInput!
  create: UserCreateWithoutChatListInput!
}

type UserVote {
  id: ID!
  user: User!
  choice: Boolean!
  vote: Vote!
}

type UserVoteConnection {
  pageInfo: PageInfo!
  edges: [UserVoteEdge]!
  aggregate: AggregateUserVote!
}

input UserVoteCreateInput {
  id: ID
  user: UserCreateOneInput!
  choice: Boolean!
  vote: VoteCreateOneWithoutVoteListInput!
}

input UserVoteCreateManyWithoutVoteInput {
  create: [UserVoteCreateWithoutVoteInput!]
  connect: [UserVoteWhereUniqueInput!]
}

input UserVoteCreateWithoutVoteInput {
  id: ID
  user: UserCreateOneInput!
  choice: Boolean!
}

type UserVoteEdge {
  node: UserVote!
  cursor: String!
}

enum UserVoteOrderByInput {
  id_ASC
  id_DESC
  choice_ASC
  choice_DESC
}

type UserVotePreviousValues {
  id: ID!
  choice: Boolean!
}

input UserVoteScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  choice: Boolean
  choice_not: Boolean
  AND: [UserVoteScalarWhereInput!]
  OR: [UserVoteScalarWhereInput!]
  NOT: [UserVoteScalarWhereInput!]
}

type UserVoteSubscriptionPayload {
  mutation: MutationType!
  node: UserVote
  updatedFields: [String!]
  previousValues: UserVotePreviousValues
}

input UserVoteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserVoteWhereInput
  AND: [UserVoteSubscriptionWhereInput!]
  OR: [UserVoteSubscriptionWhereInput!]
  NOT: [UserVoteSubscriptionWhereInput!]
}

input UserVoteUpdateInput {
  user: UserUpdateOneRequiredInput
  choice: Boolean
  vote: VoteUpdateOneRequiredWithoutVoteListInput
}

input UserVoteUpdateManyDataInput {
  choice: Boolean
}

input UserVoteUpdateManyMutationInput {
  choice: Boolean
}

input UserVoteUpdateManyWithoutVoteInput {
  create: [UserVoteCreateWithoutVoteInput!]
  delete: [UserVoteWhereUniqueInput!]
  connect: [UserVoteWhereUniqueInput!]
  set: [UserVoteWhereUniqueInput!]
  disconnect: [UserVoteWhereUniqueInput!]
  update: [UserVoteUpdateWithWhereUniqueWithoutVoteInput!]
  upsert: [UserVoteUpsertWithWhereUniqueWithoutVoteInput!]
  deleteMany: [UserVoteScalarWhereInput!]
  updateMany: [UserVoteUpdateManyWithWhereNestedInput!]
}

input UserVoteUpdateManyWithWhereNestedInput {
  where: UserVoteScalarWhereInput!
  data: UserVoteUpdateManyDataInput!
}

input UserVoteUpdateWithoutVoteDataInput {
  user: UserUpdateOneRequiredInput
  choice: Boolean
}

input UserVoteUpdateWithWhereUniqueWithoutVoteInput {
  where: UserVoteWhereUniqueInput!
  data: UserVoteUpdateWithoutVoteDataInput!
}

input UserVoteUpsertWithWhereUniqueWithoutVoteInput {
  where: UserVoteWhereUniqueInput!
  update: UserVoteUpdateWithoutVoteDataInput!
  create: UserVoteCreateWithoutVoteInput!
}

input UserVoteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  choice: Boolean
  choice_not: Boolean
  vote: VoteWhereInput
  AND: [UserVoteWhereInput!]
  OR: [UserVoteWhereInput!]
  NOT: [UserVoteWhereInput!]
}

input UserVoteWhereUniqueInput {
  id: ID
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  bossChatList_every: ChatRoomWhereInput
  bossChatList_some: ChatRoomWhereInput
  bossChatList_none: ChatRoomWhereInput
  chatList_every: ChatRoomWhereInput
  chatList_some: ChatRoomWhereInput
  chatList_none: ChatRoomWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  number: Int
}

type Vote {
  id: ID!
  chatRoom: ChatRoom!
  voteList(where: UserVoteWhereInput, orderBy: UserVoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserVote!]
}

type VoteConnection {
  pageInfo: PageInfo!
  edges: [VoteEdge]!
  aggregate: AggregateVote!
}

input VoteCreateInput {
  id: ID
  chatRoom: ChatRoomCreateOneInput!
  voteList: UserVoteCreateManyWithoutVoteInput
}

input VoteCreateOneWithoutVoteListInput {
  create: VoteCreateWithoutVoteListInput
  connect: VoteWhereUniqueInput
}

input VoteCreateWithoutVoteListInput {
  id: ID
  chatRoom: ChatRoomCreateOneInput!
}

type VoteEdge {
  node: Vote!
  cursor: String!
}

enum VoteOrderByInput {
  id_ASC
  id_DESC
}

type VotePreviousValues {
  id: ID!
}

type VoteSubscriptionPayload {
  mutation: MutationType!
  node: Vote
  updatedFields: [String!]
  previousValues: VotePreviousValues
}

input VoteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VoteWhereInput
  AND: [VoteSubscriptionWhereInput!]
  OR: [VoteSubscriptionWhereInput!]
  NOT: [VoteSubscriptionWhereInput!]
}

input VoteUpdateInput {
  chatRoom: ChatRoomUpdateOneRequiredInput
  voteList: UserVoteUpdateManyWithoutVoteInput
}

input VoteUpdateOneRequiredWithoutVoteListInput {
  create: VoteCreateWithoutVoteListInput
  update: VoteUpdateWithoutVoteListDataInput
  upsert: VoteUpsertWithoutVoteListInput
  connect: VoteWhereUniqueInput
}

input VoteUpdateWithoutVoteListDataInput {
  chatRoom: ChatRoomUpdateOneRequiredInput
}

input VoteUpsertWithoutVoteListInput {
  update: VoteUpdateWithoutVoteListDataInput!
  create: VoteCreateWithoutVoteListInput!
}

input VoteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  chatRoom: ChatRoomWhereInput
  voteList_every: UserVoteWhereInput
  voteList_some: UserVoteWhereInput
  voteList_none: UserVoteWhereInput
  AND: [VoteWhereInput!]
  OR: [VoteWhereInput!]
  NOT: [VoteWhereInput!]
}

input VoteWhereUniqueInput {
  id: ID
}
`
      }
    